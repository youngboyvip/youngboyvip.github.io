<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/youngboy/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/youngboy/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/youngboy/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/youngboy/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/youngboy/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/youngboy/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/youngboy/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="youngboy">










<meta name="description" content="Java相关文章和Activiti相关文章">
<meta name="keywords" content="youngboy的个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="youngboy">
<meta property="og:url" content="http://www.youngboy.vip/page/13/index.html">
<meta property="og:site_name" content="youngboy">
<meta property="og:description" content="Java相关文章和Activiti相关文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="youngboy">
<meta name="twitter:description" content="Java相关文章和Activiti相关文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/youngboy/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.youngboy.vip/page/13/">





  <title>youngboy</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/youngboy/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">youngboy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Java大杂烩</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/youngboy/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/youngboy/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/youngboy/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/youngboy/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/youngboy/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/11/126/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/11/126/" itemprop="url">美团-基础篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->
<ul>
<li><a href="#1-systemoutprintln3-|-9输出什么">1.  <code>System.out.println(3 | 9);</code>输出什么？</a></li>
<li><a href="#2-说一下转发forward和重定向redirect的区别">2. 说一下转发(Forward)和重定向(Redirect)的区别</a></li>
<li><a href="#3-在浏览器中输入url地址到显示主页的过程整个过程会使用哪些协议">3.  在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</a></li>
<li><a href="#4-tcp-三次握手和四次挥手">4.  TCP 三次握手和四次挥手</a><ul>
<li><a href="#为什么要三次握手">为什么要三次握手</a></li>
<li><a href="#为什么要传回-syn">为什么要传回 SYN</a></li>
<li><a href="#传了-syn为啥还要传-ack">传了 SYN,为啥还要传 ACK</a></li>
<li><a href="#为什么要四次挥手">为什么要四次挥手</a></li>
</ul>
</li>
<li><a href="#5-ip地址与mac地址的区别">5. IP地址与MAC地址的区别</a></li>
<li><a href="#6-http请求响应报文格式">6. HTTP请求、响应报文格式</a></li>
<li><a href="#7-为什么要使用索引索引这么多优点为什么不对表中的每一个列创建一个索引呢索引是如何提高查询速度的说一下使用索引的注意事项mysql索引主要使用的两种数据结构什么是覆盖索引">7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</a></li>
<li><a href="#8-进程与线程的区别是什么进程间的几种通信方式说一下线程间的几种通信方式知道不">8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</a></li>
<li><a href="#9-为什么要用单例模式手写几种线程安全的单例模式">9. 为什么要用单例模式？手写几种线程安全的单例模式？</a></li>
<li><a href="#10-简单介绍一下bean知道spring的bean的作用域与生命周期吗">10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</a></li>
<li><a href="#11-spring-中的事务传播行为了解吗transactiondefinition-接口中哪五个表示隔离级别的常量">11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</a><ul>
<li><a href="#事务传播行为">事务传播行为</a></li>
<li><a href="#隔离级别">隔离级别</a></li>
</ul>
</li>
<li><a href="#12-springmvc-原理了解吗">12. SpringMVC 原理了解吗？</a></li>
<li><a href="#13-spring-aop-ioc-实现原理">13. Spring AOP IOC 实现原理</a></li>
</ul>
<!-- /MarkdownTOC -->
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-10/3586727.jpg" alt="备战春招/秋招系列】美团面经总结基础篇 （附详解答案）"></p>
<p><strong>系列文章：</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484573&amp;idx=1&amp;sn=8c5965d4a3710d405d8e8cc10c7b0ce5&amp;chksm=fd9852fccaefdbea8dfe0bc40188b7579f1cddb1e8905dc981669a3f21d2a04cadceafa9023f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列1】程序员的简历就该这样写</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484592&amp;idx=1&amp;sn=6d9731ce7401be49e97c1af6ed384ecc&amp;chksm=fd9852d1caefdbc720a361ae65a8ad9d53cfb4800b15a7c68cbdc630b313215c6c52e0934ec2&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列3】Java程序员必备书单</a></li>
</ul>
<p>这是我总结的美团面经的基础篇，后面还有进阶和终结篇哦！下面只是我从很多份美团面经中总结的在面试中一些常见的问题。不同于个人面经，这份面经具有普适性。每次面试必备的自我介绍、项目介绍这些东西，大家可以自己私下好好思考。我在前面的文章中也提到了应该怎么做自我介绍与项目介绍，详情可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a>。</p>
<h3 id="1-System-out-println-3-9-输出什么？"><a href="#1-System-out-println-3-9-输出什么？" class="headerlink" title="1.  System.out.println(3 | 9);输出什么？"></a>1.  <code>System.out.println(3 | 9);</code>输出什么？</h3><p>正确答案：11.</p>
<p><strong>考察知识点：&amp;和&amp;&amp;；|和||</strong></p>
<p><strong>&amp;和&amp;&amp;：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；</p>
<p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。</p>
<p><strong>|和||：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false；</p>
<p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。</p>
<p><strong>回到本题：</strong></p>
<p>3 | 9=0011（二进制） | 1001（二进制）=1011（二进制）=11（十进制）</p>
<h3 id="2-说一下转发-Forward-和重定向-Redirect-的区别"><a href="#2-说一下转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="2. 说一下转发(Forward)和重定向(Redirect)的区别"></a>2. 说一下转发(Forward)和重定向(Redirect)的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forword）</strong> 通过RequestDispatcher对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure>
<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><strong>从地址栏显示来说:</strong> forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li>
<li><strong>从数据共享来说:</strong> forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</li>
<li><strong>从运用地方来说:</strong> forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</li>
<li><strong>从效率来说:</strong> forward:高. redirect:低.</li>
</ol>
<h3 id="3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议"><a href="#3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议"></a>3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</h3><p>图解（图片来源：《图解HTTP》）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="状态码"></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h3 id="4-TCP-三次握手和四次挥手"><a href="#4-TCP-三次握手和四次挥手" class="headerlink" title="4. TCP 三次握手和四次挥手"></a>4. TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p><strong>漫画图解：</strong></p>
<p>图片来源：《图解HTTP》<br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&amp;h=439&amp;f=png&amp;s=226095" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&amp;h=427&amp;f=jpeg&amp;s=15088" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&amp;h=340&amp;f=jpeg&amp;s=13406" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h3 id="5-IP地址与MAC地址的区别"><a href="#5-IP地址与MAC地址的区别" class="headerlink" title="5. IP地址与MAC地址的区别"></a>5. IP地址与MAC地址的区别</h3><p>参考：<a href="https://blog.csdn.net/guoweimelon/article/details/50858597" target="_blank" rel="noopener">https://blog.csdn.net/guoweimelon/article/details/50858597</a></p>
<p>IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<p>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。</p>
<h3 id="6-HTTP请求-响应报文格式"><a href="#6-HTTP请求-响应报文格式" class="headerlink" title="6. HTTP请求,响应报文格式"></a>6. HTTP请求,响应报文格式</h3><p>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成</p>
<p>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成</p>
<p>详细内容可以参考：<a href="https://blog.csdn.net/a19881029/article/details/14002273" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/14002273</a></p>
<h3 id="7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引"><a href="#7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引" class="headerlink" title="7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?"></a>7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</h3><p><strong>为什么要使用索引？</strong></p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 </li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
<p><strong>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</strong></p>
<ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 </li>
</ol>
<p><strong>索引是如何提高查询速度的？</strong></p>
<p>将无序的数据变成相对有序的数据（就像查目录一样）</p>
<p><strong>说一下使用索引的注意事项</strong></p>
<ol>
<li>避免 where 子句中对宇段施加函数，这会造成无法命中索引。</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ol>
<p><strong>Mysql索引主要使用的哪两种数据结构？</strong></p>
<ul>
<li>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
<li>BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</li>
</ul>
<p>更多关于索引的内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484486&amp;idx=1&amp;sn=215450f11e042bca8a58eac9f4a97686&amp;chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a></p>
<p><strong>什么是覆盖索引?</strong></p>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"><a href="#8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？" class="headerlink" title="8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"></a>8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</h3><p> <strong>进程与线程的区别是什么？</strong></p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p>
<p><strong>进程间的几种通信方式说一下？</strong></p>
<ol>
<li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li>
<li><strong>信号量（semophore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li>
<li><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li>
<li><strong>共享内存（shared memory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字（socket）</strong>：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。</li>
</ol>
<p><strong>线程间的几种通信方式知道不？</strong></p>
<p>1、锁机制</p>
<ul>
<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>
<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>
<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<p>2、信号量机制：包括无名线程信号量与有名线程信号量</p>
<p>3、信号机制：类似于进程间的信号处理。</p>
<p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p>
<h3 id="9-为什么要用单例模式？手写几种线程安全的单例模式？"><a href="#9-为什么要用单例模式？手写几种线程安全的单例模式？" class="headerlink" title="9. 为什么要用单例模式？手写几种线程安全的单例模式？"></a>9. 为什么要用单例模式？手写几种线程安全的单例模式？</h3><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>懒汉式(双重检查加锁版本)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只有第一次才彻底执行这里的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">               <span class="comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态内部类方式</strong></p>
<p>静态内部实现的单例是懒加载的且线程安全。</p>
<p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"><a href="#10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？" class="headerlink" title="10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"></a>10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</h3><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p>
<p>Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45773d5dd2e?w=563&amp;h=299&amp;f=webp&amp;s=27930" alt="pring的bean的作用域"></p>
<p>Spring的bean的生命周期以及更多内容可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484400&amp;idx=2&amp;sn=7201eb365102fce017f89cb3527fb0bc&amp;chksm=fd985591caefdc872a2fac897288119f94c345e4e12150774f960bf5f816b79e4b9b46be3d7f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一文轻松搞懂Spring中bean的作用域与生命周期</a></p>
<h3 id="11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？"><a href="#11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？" class="headerlink" title="11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？"></a>11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</h3><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="12-SpringMVC-原理了解吗？"><a href="#12-SpringMVC-原理了解吗？" class="headerlink" title="12. SpringMVC 原理了解吗？"></a>12. SpringMVC 原理了解吗？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45787394192?w=1015&amp;h=466&amp;f=webp&amp;s=35352" alt="SpringMVC 原理"></p>
<p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户</p>
<p>关于 SpringMVC 原理更多内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484496&amp;idx=1&amp;sn=5472ffa687fe4a05f8900d8ee6726de4&amp;chksm=fd985231caefdb27fc75b44ecf76b6f43e4617e0b01b3c040f8b8fab32e51dfa5118eed1d6ad&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p>
<h3 id="13-Spring-AOP-IOC-实现原理"><a href="#13-Spring-AOP-IOC-实现原理" class="headerlink" title="13. Spring AOP IOC 实现原理"></a>13. Spring AOP IOC 实现原理</h3><p>过了秋招挺长一段时间了，说实话我自己也忘了如何简要概括 Spring AOP IOC 实现原理，就在网上找了一个较为简洁的答案，下面分享给各位。</p>
<p><strong>IOC:</strong> 控制反转也叫依赖注入。IOC利用java反射机制，AOP利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。</p>
<p><strong>AOP：</strong> 面向切面编程。（Aspect-Oriented Programming） 。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/11/125/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/11/125/" itemprop="url">简历模板</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>手机：</li>
<li>Email：</li>
<li>微信：</li>
</ul>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>姓名/性别/出生日期 </li>
<li>本科/xxx计算机系xxx专业/英语六级</li>
<li>技术博客：<a href="http://snailclimb.top/" target="_blank" rel="noopener">http://snailclimb.top/</a> </li>
<li>荣誉奖励：获得了什么奖（获奖时间）</li>
<li>Github：<a href="https://github.com/Snailclimb" target="_blank" rel="noopener">https://github.com/Snailclimb </a></li>
<li>Github Resume: <a href="http://resume.github.io/?Snailclimb" target="_blank" rel="noopener">http://resume.github.io/?Snailclimb</a></li>
<li>期望职位：Java 研发程序员/大数据工程师(Java后台开发为首选)</li>
<li>期望城市：xxx城市</li>
</ul>
<h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="xxx项目"><a href="#xxx项目" class="headerlink" title="xxx项目"></a>xxx项目</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>介绍该项目是做什么的、使用到了什么技术以及你对项目整体设计的一个感受</p>
<h3 id="责任描述"><a href="#责任描述" class="headerlink" title="责任描述"></a>责任描述</h3><p>主要可以从下面三点来写：</p>
<ol>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h1 id="开源项目和技术文章"><a href="#开源项目和技术文章" class="headerlink" title="开源项目和技术文章"></a>开源项目和技术文章</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul>
<li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">Java-Guide</a> ：一份涵盖大部分Java程序员所需要掌握的核心知识。Star:3.9K; Fork:0.9k。</li>
</ul>
<h2 id="技术文章推荐"><a href="#技术文章推荐" class="headerlink" title="技术文章推荐"></a>技术文章推荐</h2><ul>
<li><a href="https://juejin.im/post/5b7d69e4e51d4538ca5730cb" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a></li>
<li><a href="https://juejin.im/post/5b85ea54e51d4538dd08f601" target="_blank" rel="noopener">搞定JVM垃圾回收就是这么简单</a></li>
<li><a href="https://juejin.im/post/5b3b19856fb9a04fa42f8c71" target="_blank" rel="noopener">前端&amp;后端程序员必备的Linux基础知识</a></li>
<li><a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></li>
</ul>
<h1 id="校园经历（可选）"><a href="#校园经历（可选）" class="headerlink" title="校园经历（可选）"></a>校园经历（可选）</h1><h2 id="2016-2017"><a href="#2016-2017" class="headerlink" title="2016-2017"></a>2016-2017</h2><p>担任学校社团-致深社副会长，主要负责团队每周活动的组建以及每周例会的主持。</p>
<h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p> 担任学校传媒组织：“长江大学在线信息传媒”的副站长以及安卓组成员。主要负责每周例会主持、活动策划以及学校校园通APP的研发工作。</p>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p>
<ul>
<li>Web开发：PHP/Hack/Node</li>
<li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li>
<li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li>
<li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li>
<li>数据库相关：MySQL/PgSQL/PDO/SQLite</li>
<li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li>
<li>单元测试：PHPUnit/SimpleTest/Qunit</li>
<li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li>
</ul>
<h1 id="自我评价（可选）"><a href="#自我评价（可选）" class="headerlink" title="自我评价（可选）"></a>自我评价（可选）</h1><p>自我发挥。切记不要过度自夸！！！</p>
<h3 id="感谢您花时间阅读我的简历，期待能有机会和您共事。"><a href="#感谢您花时间阅读我的简历，期待能有机会和您共事。" class="headerlink" title="感谢您花时间阅读我的简历，期待能有机会和您共事。"></a>感谢您花时间阅读我的简历，期待能有机会和您共事。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/11/124/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/11/124/" itemprop="url">程序员的简历之道</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序员的简历就该这样写"><a href="#程序员的简历就该这样写" class="headerlink" title="程序员的简历就该这样写"></a>程序员的简历就该这样写</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p><font color="red">一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。</font> 在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。</p>
<h3 id="2-为什么说简历很重要？"><a href="#2-为什么说简历很重要？" class="headerlink" title="2 为什么说简历很重要？"></a>2 为什么说简历很重要？</h3><h4 id="2-1-先从面试前来说"><a href="#2-1-先从面试前来说" class="headerlink" title="2.1 先从面试前来说"></a>2.1 先从面试前来说</h4><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<p>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p>
<h4 id="2-2-再从面试中来说"><a href="#2-2-再从面试中来说" class="headerlink" title="2.2 再从面试中来说"></a>2.2 再从面试中来说</h4><p>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</p>
<p>所以，首先，你要明确的一点是：<strong>你不会的东西就不要写在简历上</strong>。另外，<strong>你要考虑你该如何才能让你的亮点在简历中凸显出来</strong>，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p>
<p>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</p>
<h3 id="3-下面这几点你必须知道"><a href="#3-下面这几点你必须知道" class="headerlink" title="3 下面这几点你必须知道"></a>3 下面这几点你必须知道</h3><ol>
<li>大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</li>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</strong></li>
<li><strong>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h3 id="4-必须了解的两大法则"><a href="#4-必须了解的两大法则" class="headerlink" title="4  必须了解的两大法则"></a>4  必须了解的两大法则</h3><p><strong>①STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<p>下面这段内容摘自百度百科，我觉得写的非常不错：</p>
<blockquote>
<p>STAR法则，500强面试题回答时的技巧法则，备受面试者成功者和500强HR的推崇。<br>由于这个法则被广泛应用于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强，不至于在一个月后去面试，却把简历里的东西都忘掉了（更何况有些朋友会稍微夸大简历内容）<br>在我们写简历时，每个人都要写上自己的工作经历，活动经历，想必每一个同学，都会起码花上半天甚至更长的时间去搜寻脑海里所有有关的经历，争取找出最好的东西写在简历上。<br>但是此时，我们要注意了，简历上的任何一个信息点都有可能成为日后面试时的重点提问对象，所以说，不能只管写上让自己感觉最牛的经历就完事了，要想到今后，在面试中，你所写的经历万一被面试官问到，你真的能回答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？</p>
</blockquote>
<p><strong>②FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<p>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</p>
<h3 id="5-项目经历怎么写？"><a href="#5-项目经历怎么写？" class="headerlink" title="5 项目经历怎么写？"></a>5 项目经历怎么写？</h3><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h3 id="6-专业技能该怎么写？"><a href="#6-专业技能该怎么写？" class="headerlink" title="6 专业技能该怎么写？"></a>6 专业技能该怎么写？</h3><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写(下面这部分内容摘自我的简历，大家可以根据自己的情况做一些修改和完善)：</p>
<ul>
<li>计算机网络、数据结构、算法、操作系统等课内基础知识：掌握</li>
<li>Java 基础知识：掌握</li>
<li>JVM 虚拟机（Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理）：掌握</li>
<li>高并发、高可用、高性能系统开发：掌握</li>
<li>Struts2、Spring、Hibernate、Ajax、Mybatis、JQuery ：掌握</li>
<li>SSH 整合、SSM 整合、 SOA 架构：掌握</li>
<li>Dubbo： 掌握</li>
<li>Zookeeper: 掌握</li>
<li>常见消息队列: 掌握</li>
<li>Linux：掌握</li>
<li>MySQL常见优化手段：掌握 </li>
<li>Spring Boot +Spring Cloud +Docker:了解</li>
<li>Hadoop 生态相关技术中的 HDFS、Storm、MapReduce、Hive、Hbase ：了解</li>
<li>Python 基础、一些常见第三方库比如OpenCV、wxpy、wordcloud、matplotlib：熟悉</li>
</ul>
<h3 id="7-开源程序员Markdown格式简历模板分享"><a href="#7-开源程序员Markdown格式简历模板分享" class="headerlink" title="7 开源程序员Markdown格式简历模板分享"></a>7 开源程序员Markdown格式简历模板分享</h3><p>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。<br>Github地址：<a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a></p>
<p>我的下面这篇文章讲了如何写一份Markdown格式的简历，另外，文中还提到了一种实现 Markdown 格式到PDF、HTML、JPEG这几种格式的转换方法。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484347&amp;idx=1&amp;sn=a986ea7e199871999a5257bd3ed78be1&amp;chksm=fd9855dacaefdccc2c5d5f8f79c4aa1b608ad5b42936bccaefb99a850a2e6e8e2e910e1b3153&amp;token=719595858&amp;lang=zh_CN#rd" target="_blank" rel="noopener">手把手教你用Markdown写一份高质量的简历</a></p>
<h3 id="8-其他的一些小tips"><a href="#8-其他的一些小tips" class="headerlink" title="8 其他的一些小tips"></a>8 其他的一些小tips</h3><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/11/113/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/11/113/" itemprop="url">手把手教你用Markdown写一份高质量的简历</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Markdown-简历模板样式一览"><a href="#Markdown-简历模板样式一览" class="headerlink" title="Markdown 简历模板样式一览"></a>Markdown 简历模板样式一览</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f91e4843bd67?w=800&amp;h=1737&amp;f=png&amp;s=97357" alt><br><strong>可以看到我把联系方式放在第一位，因为公司一般会与你联系，所以把联系方式放在第一位也是为了方便联系考虑。</strong></p>
<h2 id="为什么要用-Markdown-写简历？"><a href="#为什么要用-Markdown-写简历？" class="headerlink" title="为什么要用 Markdown 写简历？"></a>为什么要用 Markdown 写简历？</h2><p>Markdown 语法简单，易于上手。使用正确的 Markdown 语言写出来的简历不论是在排版还是格式上都比较干净，易于阅读。另外，使用 Markdown 写简历也会给面试官一种你比较专业的感觉。</p>
<p>除了这些，我觉得使用 Markdown 写简历可以很方便将其与PDF、HTML、PNG格式之间转换。后面我会介绍到转换方法，只需要一条命令你就可以实现 Markdown 到 PDF、HTML 与 PNG之间的无缝切换。</p>
<blockquote>
<p>下面的一些内容我在之前的一篇文章中已经提到过，这里再说一遍，最后会分享如何实现Markdown 到 PDF、HTML、PNG格式之间转换。</p>
</blockquote>
<h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<h2 id="写简历的两大法则"><a href="#写简历的两大法则" class="headerlink" title="写简历的两大法则"></a>写简历的两大法则</h2><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p>
<p><strong>STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p>
<ul>
<li>Dubbo：精通</li>
<li>Spring：精通</li>
<li>Docker：掌握</li>
<li>SOA分布式开发 ：掌握</li>
<li>Spring Cloud:了解</li>
</ul>
<h2 id="简历模板分享"><a href="#简历模板分享" class="headerlink" title="简历模板分享"></a>简历模板分享</h2><p><strong>开源程序员简历模板</strong>： <a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a>（包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板）</p>
<p><strong>上述简历模板的改进版本：</strong> <a href="https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md</a> </p>
<h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<blockquote>
<p>我们刚刚讲了很多关于如何写简历的内容并且分享了一份 Markdown 格式的简历文档。下面我们来看看如何实现 Markdown 到 HTML格式、PNG格式之间转换。</p>
</blockquote>
<h2 id="Markdown-到-HTML格式、PNG格式之间转换"><a href="#Markdown-到-HTML格式、PNG格式之间转换" class="headerlink" title="Markdown 到 HTML格式、PNG格式之间转换"></a>Markdown 到 HTML格式、PNG格式之间转换</h2><p>网上很难找到一个比较方便并且效果好的转换方法，最后我是通过 Visual Studio Code 的 Markdown PDF 插件完美解决了这个问题！</p>
<h3 id="安装-Markdown-PDF-插件"><a href="#安装-Markdown-PDF-插件" class="headerlink" title="安装 Markdown PDF 插件"></a>安装 Markdown PDF 插件</h3><p><strong>① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9a44103e551?w=1366&amp;h=688&amp;f=png&amp;s=104435" alt="① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项"></p>
<p><strong>② 搜索 “Markdown PDF” 插件并安装 ，然后重启</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9dbef0d06fb?w=1280&amp;h=420&amp;f=png&amp;s=70510" alt="② 搜索 “Markdown PDF” 插件并安装 ，然后重启"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>随便打开一份 Markdown 文件 点击F1，然后输入export即可！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659fa0292906150?w=1289&amp;h=468&amp;f=png&amp;s=72178" alt></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/7/8/83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/7/8/83/" itemprop="url">Redlock分布式锁</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据存储/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据存储/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这篇文章主要是对 Redis 官方网站刊登的 <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener">Distributed locks with Redis</a> 部分内容的总结和翻译。</p>
<h2 id="什么是-RedLock"><a href="#什么是-RedLock" class="headerlink" title="什么是 RedLock"></a>什么是 RedLock</h2><p>Redis 官方站这篇文章提出了一种权威的基于 Redis 实现分布式锁的方式名叫 <em>Redlock</em>，此种方式比原先的单节点的方法更安全。它可以保证以下特性：</p>
<ol>
<li>安全特性：互斥访问，即永远只有一个 client 能拿到锁</li>
<li>避免死锁：最终 client 都可能拿到锁，不会出现死锁的情况，即使原本锁住某资源的 client crash 了或者出现了网络分区</li>
<li>容错性：只要大部分 Redis 节点存活就可以正常提供服务</li>
</ol>
<h2 id="怎么在单节点上实现分布式锁"><a href="#怎么在单节点上实现分布式锁" class="headerlink" title="怎么在单节点上实现分布式锁"></a>怎么在单节点上实现分布式锁</h2><blockquote>
<p>SET resource_name my_random_value NX PX 30000</p>
</blockquote>
<p>主要依靠上述命令，该命令仅当 Key 不存在时（NX保证）set 值，并且设置过期时间 3000ms （PX保证），值 my_random_value 必须是所有 client 和所有锁请求发生期间唯一的，释放锁的逻辑是：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>上述实现可以避免释放另一个client创建的锁，如果只有 del 命令的话，那么如果 client1 拿到 lock1 之后因为某些操作阻塞了很长时间，此时 Redis 端 lock1 已经过期了并且已经被重新分配给了 client2，那么 client1 此时再去释放这把锁就会造成 client2 原本获取到的锁被 client1 无故释放了，但现在为每个 client 分配一个 unique 的 string 值可以避免这个问题。至于如何去生成这个 unique string，方法很多随意选择一种就行了。</p>
<h2 id="Redlock-算法"><a href="#Redlock-算法" class="headerlink" title="Redlock 算法"></a>Redlock 算法</h2><p>算法很易懂，起 5 个 master 节点，分布在不同的机房尽量保证可用性。为了获得锁，client 会进行如下操作：</p>
<ol>
<li>得到当前的时间，微妙单位</li>
<li>尝试顺序地在 5 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个 client 需要合理设置与 master 节点沟通的 timeout 大小，避免长时间和一个 fail 了的节点浪费时间</li>
<li>当 client 在大于等于 3 个 master 上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。</li>
<li>如果锁申请到了，那么锁真正的 lock validity time 应该是 origin（lock validity time） - 申请锁期间流逝的时间</li>
<li>如果 client 申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态</li>
</ol>
<h2 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h2><p>如果一个 client 申请锁失败了，那么它需要稍等一会在重试避免多个 client 同时申请锁的情况，最好的情况是一个 client 需要几乎同时向 5 个 master 发起锁申请。另外就是如果 client 申请锁失败了它需要尽快在它曾经申请到锁的 master 上执行 unlock 操作，便于其他 client 获得这把锁，避免这些锁过期造成的时间浪费，当然如果这时候网络分区使得 client 无法联系上这些 master，那么这种浪费就是不得不付出的代价了。</p>
<h2 id="放锁"><a href="#放锁" class="headerlink" title="放锁"></a>放锁</h2><p>放锁操作很简单，就是依次释放所有节点上的锁就行了</p>
<h2 id="性能、崩溃恢复和-fsync"><a href="#性能、崩溃恢复和-fsync" class="headerlink" title="性能、崩溃恢复和 fsync"></a>性能、崩溃恢复和 fsync</h2><p>如果我们的节点没有持久化机制，client 从 5 个 master 中的 3 个处获得了锁，然后其中一个重启了，这是注意 <strong>整个环境中又出现了 3 个 master 可供另一个 client 申请同一把锁！</strong> 违反了互斥性。如果我们开启了 AOF 持久化那么情况会稍微好转一些，因为 Redis 的过期机制是语义层面实现的，所以在 server 挂了的时候时间依旧在流逝，重启之后锁状态不会受到污染。但是考虑断电之后呢，AOF部分命令没来得及刷回磁盘直接丢失了，除非我们配置刷回策略为 fsnyc = always，但这会损伤性能。解决这个问题的方法是，当一个节点重启之后，我们规定在 max TTL 期间它是不可用的，这样它就不会干扰原本已经申请到的锁，等到它 crash 前的那部分锁都过期了，环境不存在历史锁了，那么再把这个节点加进来正常工作。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/7/72/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/7/72/" itemprop="url">MySQL</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据存储/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java面试通关手册（Java学习指南，欢迎Star，会一直完善下去，欢迎建议和指导）：<a href="https://github.com/Snailclimb/Java_Guide" target="_blank" rel="noopener">https://github.com/Snailclimb/Java_Guide</a></p>
<blockquote>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2></blockquote>
<p><strong>《高性能MySQL : 第3版》</strong></p>
<blockquote>
<h2 id="文字教程推荐"><a href="#文字教程推荐" class="headerlink" title="文字教程推荐"></a>文字教程推荐</h2></blockquote>
<p><a href="http://www.runoob.com/mysql/mysql-tutorial.html" target="_blank" rel="noopener">MySQL 教程（菜鸟教程）</a></p>
<p><a href="https://www.yiibai.com/mysql/" target="_blank" rel="noopener">MySQL教程（易百教程）</a></p>
<blockquote>
<h2 id="视频教程推荐"><a href="#视频教程推荐" class="headerlink" title="视频教程推荐"></a>视频教程推荐</h2></blockquote>
<p><strong>基础入门：</strong> <a href="https://www.imooc.com/learn/122" target="_blank" rel="noopener">与MySQL的零距离接触-慕课网</a></p>
<p><strong>Mysql开发技巧：</strong> <a href="https://www.imooc.com/learn/398" target="_blank" rel="noopener">MySQL开发技巧（一）</a>　　<a href="https://www.imooc.com/learn/427" target="_blank" rel="noopener">MySQL开发技巧（二）</a>　　<a href="https://www.imooc.com/learn/449" target="_blank" rel="noopener">MySQL开发技巧（三）</a></p>
<p><strong>Mysql5.7新特性及相关优化技巧：</strong> <a href="https://www.imooc.com/learn/533" target="_blank" rel="noopener">MySQL5.7版本新特性</a>　　<a href="https://www.imooc.com/learn/194" target="_blank" rel="noopener">性能优化之MySQL优化</a></p>
<p><a href="https://www.imooc.com/learn/993" target="_blank" rel="noopener">MySQL集群（PXC）入门</a>　　<a href="https://www.imooc.com/learn/951" target="_blank" rel="noopener">MyCAT入门及应用</a></p>
<blockquote>
<h2 id="常见问题总结"><a href="#常见问题总结" class="headerlink" title="常见问题总结"></a>常见问题总结</h2></blockquote>
<ul>
<li><h3 id="①存储引擎"><a href="#①存储引擎" class="headerlink" title="①存储引擎"></a>①存储引擎</h3><p><a href="https://juejin.im/post/5b1685bef265da6e5c3c1c34" target="_blank" rel="noopener">MySQL常见的两种存储引擎：MyISAM与InnoDB的爱恨情仇</a></p>
</li>
<li><h3 id="②字符集及校对规则"><a href="#②字符集及校对规则" class="headerlink" title="②字符集及校对规则"></a>②字符集及校对规则</h3><p> 字符集指的是一种从二进制编码到某类字符符号的映射。校对规则则是指某种字符集下的排序规则。Mysql中每一种字符集都会对应一系列的校对规则。</p>
<p> Mysql采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集） PS：整理自《Java工程师修炼之道》</p>
<p> 详细内容可以参考：   <a href="https://www.cnblogs.com/geaozhang/p/6724393.html#mysqlyuzifuji" target="_blank" rel="noopener">MySQL字符集及校对规则的理解</a></p>
</li>
<li><h3 id="③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）"><a href="#③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）" class="headerlink" title="③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）"></a>③索引相关的内容（数据库使用中非常关键的技术，合理正确的使用索引可以大大提高数据库的查询性能）</h3><p>　　Mysql索引使用的数据结构主要有<strong>BTree索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>
<p>　　Mysql的BTree索引使用的是B数中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<p>　　<strong>MyISAM:</strong> B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>　　<strong>InnoDB:</strong> 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。</strong> <strong>因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</strong> PS：整理自《Java工程师修炼之道》</p>
<p> 详细内容可以参考：</p>
<p> <a href="https://www.jianshu.com/p/1775b4ff123a" target="_blank" rel="noopener">干货：mysql索引的数据结构</a></p>
<p> <a href="https://blog.csdn.net/Jack__Frost/article/details/72571540" target="_blank" rel="noopener">MySQL优化系列（三）–索引的使用、原理和设计优化</a></p>
<p> <a href="https://juejin.im/post/5b55b842f265da0f9e589e79#comment" target="_blank" rel="noopener">数据库两大神器【索引和锁】</a></p>
</li>
<li><h3 id="④查询缓存的使用"><a href="#④查询缓存的使用" class="headerlink" title="④查询缓存的使用"></a>④查询缓存的使用</h3><p> my.cnf加入以下配置，重启Mysql开启查询缓存</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">query_cache_type=1</span><br><span class="line">query_cache_size=600000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>   Mysql执行以下命令也可以开启查询缓存</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global  query_cache_type=1;</span><br><span class="line">set global  query_cache_size=600000;</span><br></pre></td></tr></table></figure>
<p>   如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、Mysql库中的系统表，其查询结果也不会被缓存。</p>
<p>   缓存建立之后，Mysql的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>
<p>   <strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，<strong>还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：</strong><br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sql_no_cache count(*) from usr;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><h3 id="⑤事务机制"><a href="#⑤事务机制" class="headerlink" title="⑤事务机制"></a>⑤事务机制</h3><p> <strong>关系性数据库需要遵循ACID规则，具体内容如下：</strong></p>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/20/1637b08b98619455?w=312&amp;h=305&amp;f=png&amp;s=22430" alt="事务的特性"></p>
<ol>
<li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性：</strong> 执行事务前后，数据保持一致；</li>
<li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事物不被其他事物所干扰，各并发事务之间数据库是独立的；</li>
<li><p><strong>持久性:</strong>  一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库 发生故障也不应该对其有任何影响。</p>
<p><strong>为了达到上述事务特性，数据库定义了几种不同的事务隔离级别：</strong></p>
</li>
</ol>
<ul>
<li><strong>READ_UNCOMMITTED（未授权读取）:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong>READ_COMMITTED（授权读取）:</strong>     允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong>REPEATABLE_READ（可重复读）:</strong>     对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><p><strong>SERIALIZABLE（串行）:</strong>     最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p>
<p>这里需要注意的是：<strong>Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</strong></p>
<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>
<p> 详细内容可以参考：   <a href="https://blog.csdn.net/qq_34337272/article/details/80394121" target="_blank" rel="noopener">可能是最漂亮的Spring事务管理详解</a></p>
</li>
<li><h3 id="⑥锁机制与InnoDB锁算法"><a href="#⑥锁机制与InnoDB锁算法" class="headerlink" title="⑥锁机制与InnoDB锁算法"></a>⑥锁机制与InnoDB锁算法</h3><p> <strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li><p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
<p><strong>表级锁和行级锁对比：</strong></p>
<ul>
<li><strong>表级锁：</strong> Mysql中锁定 <strong>粒度最大</strong> 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> Mysql中锁定 <strong>粒度最小</strong> 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 </li>
</ul>
<p>详细内容可以参考：<br><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">Mysql锁机制简单了解一下</a></p>
</li>
</ul>
<p><strong>InnoDB存储引擎的锁的算法有三种：</strong></p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p>
<p><strong>相关知识点：</strong></p>
<ol>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ol>
</li>
</ul>
</li>
<li><h3 id="⑦大表优化"><a href="#⑦大表优化" class="headerlink" title="⑦大表优化"></a>⑦大表优化</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
<li><p><strong>垂直分区：</strong> </p>
<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>
<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。<br><img src="https://user-gold-cdn.xitu.io/2018/6/16/164084354ba2e0fd?w=950&amp;h=279&amp;f=jpeg&amp;s=26015" alt></p>
<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>
<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
</li>
<li><p><strong>水平分区：</strong> </p>
</li>
</ol>
</li>
</ul>
<pre><code>**保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。** 

水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

![数据库水平拆分](https://user-gold-cdn.xitu.io/2018/6/16/164084b7e9e423e3?w=690&amp;h=271&amp;f=jpeg&amp;s=23119)

水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水品拆分最好分库** 。

水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决**  ，跨界点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。

**下面补充一下数据库分片的两种常见方案：**
- **客户端代理：**  **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。
- **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。
</code></pre><p>  详细内容可以参考：<br>  <a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">MySQL大表优化方案</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/05/28/7/8/84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/05/28/7/8/84/" itemprop="url">如何做可靠的分布式锁，Redlock真的可行么</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T17:18:24+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据存储/" itemprop="url" rel="index">
                    <span itemprop="name">数据存储</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据存储/Redis/" itemprop="url" rel="index">
                    <span itemprop="name">Redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是对 <a href="https://martin.kleppmann.com/" target="_blank" rel="noopener">Martin Kleppmann</a> 的文章 <a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener">How to do distributed locking</a> 部分内容的翻译和总结，上次写 Redlock 的原因就是看到了 Martin 的这篇文章，写得很好，特此翻译和总结。感兴趣的同学可以翻看原文，相信会收获良多。</p>
<p>开篇作者认为现在 Redis 逐渐被使用到数据管理领域，这个领域需要更强的数据一致性和耐久性，这使得他感到担心，因为这不是 Redis 最初设计的初衷（事实上这也是很多业界程序员的误区，越来越把 Redis 当成数据库在使用），其中基于 Redis 的分布式锁就是令人担心的其一。</p>
<p>Martin 指出首先你要明确你为什么使用分布式锁，为了性能还是正确性？为了帮你区分这二者，在这把锁 fail 了的时候你可以询问自己以下问题： </p>
<ol>
<li><strong>要性能的：</strong> 拥有这把锁使得你不会重复劳动（例如一个 job 做了两次），如果这把锁 fail 了，两个节点同时做了这个 Job，那么这个 Job 增加了你的成本。</li>
<li><strong>要正确性的：</strong> 拥有锁可以防止并发操作污染你的系统或者数据，如果这把锁 fail 了两个节点同时操作了一份数据，结果可能是数据不一致、数据丢失、file 冲突等，会导致严重的后果。</li>
</ol>
<p>上述二者都是需求锁的正确场景，但是你必须清楚自己是因为什么原因需要分布式锁。</p>
<p>如果你只是为了性能，那没必要用 Redlock，它成本高且复杂，你只用一个 Redis 实例也够了，最多加个从防止主挂了。当然，你使用单节点的 Redis 那么断电或者一些情况下，你会丢失锁，但是你的目的只是加速性能且断电这种事情不会经常发生，这并不是什么大问题。并且如果你使用了单节点 Redis，那么很显然你这个应用需要的锁粒度是很模糊粗糙的，也不会是什么重要的服务。</p>
<p>那么是否 Redlock 对于要求正确性的场景就合适呢？Martin 列举了若干场景证明 Redlock 这种算法是不可靠的。</p>
<h2 id="用锁保护资源"><a href="#用锁保护资源" class="headerlink" title="用锁保护资源"></a>用锁保护资源</h2><p>这节里 Martin 先将 Redlock 放在了一边而是仅讨论总体上一个分布式锁是怎么工作的。在分布式环境下，锁比 mutex 这类复杂，因为涉及到不同节点、网络通信并且他们随时可能无征兆的 fail 。<br>Martin 假设了一个场景，一个 client 要修改一个文件，它先申请得到锁，然后修改文件写回，放锁。另一个 client 再申请锁 … 代码流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS CODE IS BROKEN</span></span><br><span class="line"><span class="function">function <span class="title">writeData</span><span class="params">(filename, data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lock = lockService.acquireLock(filename);</span><br><span class="line">    <span class="keyword">if</span> (!lock) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="string">'Failed to acquire lock'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> file = storage.readFile(filename);</span><br><span class="line">        <span class="keyword">var</span> updated = updateContents(file, data);</span><br><span class="line">        storage.writeFile(filename, updated);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可惜即使你的锁服务非常完美，上述代码还是可能跪，下面的流程图会告诉你为什么：</p>
<p><img src="https://martin.kleppmann.com/2016/02/unsafe-lock.png" alt></p>
<p>上述图中，得到锁的 client1 在持有锁的期间 pause 了一段时间，例如 GC 停顿。锁有过期时间（一般叫租约，为了防止某个 client 崩溃之后一直占有锁），但是如果 GC 停顿太长超过了锁租约时间，此时锁已经被另一个 client2 所得到，原先的 client1 还没有感知到锁过期，那么奇怪的结果就会发生，曾经 HBase 就发生过这种 Bug。即使你在 client1 写回之前检查一下锁是否过期也无助于解决这个问题，因为 GC 可能在任何时候发生，即使是你非常不便的时候（在最后的检查与写操作期间）。<br>如果你认为自己的程序不会有长时间的 GC 停顿，还有其他原因会导致你的进程 pause。例如进程可能读取尚未进入内存的数据，所以它得到一个 page fault 并且等待 page 被加载进缓存；还有可能你依赖于网络服务；或者其他进程占用 CPU；或者其他人意外发生 SIGSTOP 等。</p>
<p>… …. 这里 Martin 又增加了一节列举各种进程 pause 的例子，为了证明上面的代码是不安全的，无论你的锁服务多完美。</p>
<h2 id="使用-Fencing-（栅栏）使得锁变安全"><a href="#使用-Fencing-（栅栏）使得锁变安全" class="headerlink" title="使用 Fencing （栅栏）使得锁变安全"></a>使用 Fencing （栅栏）使得锁变安全</h2><p>修复问题的方法也很简单：你需要在每次写操作时加入一个 fencing token。这个场景下，fencing token 可以是一个递增的数字（lock service 可以做到），每次有 client 申请锁就递增一次：</p>
<p><img src="https://martin.kleppmann.com/2016/02/fencing-tokens.png" alt></p>
<p>client1 申请锁同时拿到 token33，然后它进入长时间的停顿锁也过期了。client2 得到锁和 token34 写入数据，紧接着 client1 活过来之后尝试写入数据，自身 token33 比 34 小因此写入操作被拒绝。注意这需要存储层来检查 token，但这并不难实现。如果你使用 Zookeeper 作为 lock service 的话那么你可以使用 zxid 作为递增数字。<br>但是对于 Redlock 你要知道，没什么生成 fencing token 的方式，并且怎么修改 Redlock 算法使其能产生 fencing token 呢？好像并不那么显而易见。因为产生 token 需要单调递增，除非在单节点 Redis 上完成但是这又没有高可靠性，你好像需要引进一致性协议来让 Redlock 产生可靠的 fencing token。</p>
<h2 id="使用时间来解决一致性"><a href="#使用时间来解决一致性" class="headerlink" title="使用时间来解决一致性"></a>使用时间来解决一致性</h2><p>Redlock 无法产生 fencing token 早该成为在需求正确性的场景下弃用它的理由，但还有一些值得讨论的地方。</p>
<p>学术界有个说法，算法对时间不做假设：因为进程可能pause一段时间、数据包可能因为网络延迟延后到达、时钟可能根本就是错的。而可靠的算法依旧要在上述假设下做正确的事情。</p>
<p>对于 failure detector 来说，timeout 只能作为猜测某个节点 fail 的依据，因为网络延迟、本地时钟不正确等其他原因的限制。考虑到 Redis 使用 gettimeofday，而不是单调的时钟，会受到系统时间的影响，可能会突然前进或者后退一段时间，这会导致一个 key 更快或更慢地过期。</p>
<p>可见，Redlock 依赖于许多时间假设，它假设所有 Redis 节点都能对同一个 Key 在其过期前持有差不多的时间、跟过期时间相比网络延迟很小、跟过期时间相比进程 pause 很短。</p>
<h2 id="用不可靠的时间打破-Redlock"><a href="#用不可靠的时间打破-Redlock" class="headerlink" title="用不可靠的时间打破 Redlock"></a>用不可靠的时间打破 Redlock</h2><p>这节 Martin 举了个因为时间问题，Redlock 不可靠的例子。</p>
<ol>
<li>client1 从 ABC 三个节点处申请到锁，DE由于网络原因请求没有到达</li>
<li>C节点的时钟往前推了，导致 lock 过期</li>
<li>client2 在CDE处获得了锁，AB由于网络原因请求未到达</li>
<li>此时 client1 和 client2 都获得了锁</li>
</ol>
<p><strong>在 Redlock 官方文档中也提到了这个情况，不过是C崩溃的时候，Redlock 官方本身也是知道 Redlock 算法不是完全可靠的，官方为了解决这种问题建议使用延时启动，相关内容可以看之前的<a href="https://zhuanlan.zhihu.com/p/40915772" target="_blank" rel="noopener">这篇文章</a>。但是 Martin 这里分析得更加全面，指出延时启动不也是依赖于时钟的正确性的么？</strong></p>
<p>接下来 Martin 又列举了进程 Pause 时而不是时钟不可靠时会发生的问题：</p>
<ol>
<li>client1 从 ABCDE 处获得了锁</li>
<li>当获得锁的 response 还没到达 client1 时 client1 进入 GC 停顿</li>
<li>停顿期间锁已经过期了</li>
<li>client2 在 ABCDE 处获得了锁</li>
<li>client1 GC 完成收到了获得锁的 response，此时两个 client 又拿到了同一把锁</li>
</ol>
<p><strong>同时长时间的网络延迟也有可能导致同样的问题。</strong></p>
<h2 id="Redlock-的同步性假设"><a href="#Redlock-的同步性假设" class="headerlink" title="Redlock 的同步性假设"></a>Redlock 的同步性假设</h2><p>这些例子说明了，仅有在你假设了一个同步性系统模型的基础上，Redlock 才能正常工作，也就是系统能满足以下属性：</p>
<ol>
<li>网络延时边界，即假设数据包一定能在某个最大延时之内到达</li>
<li>进程停顿边界，即进程停顿一定在某个最大时间之内</li>
<li>时钟错误边界，即不会从一个坏的 NTP 服务器处取得时间</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Martin 认为 Redlock 实在不是一个好的选择，对于需求性能的分布式锁应用它太重了且成本高；对于需求正确性的应用来说它不够安全。因为它对高危的时钟或者说其他上述列举的情况进行了不可靠的假设，如果你的应用只需要高性能的分布式锁不要求多高的正确性，那么单节点 Redis 够了；如果你的应用想要保住正确性，那么不建议 Redlock，建议使用一个合适的一致性协调系统，例如 Zookeeper，且保证存在 fencing token。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/youngboy/page/12/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/youngboy/">1</a><span class="space">&hellip;</span><a class="page-number" href="/youngboy/page/12/">12</a><span class="page-number current">13</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">youngboy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/youngboy/archives/">
              
                  <span class="site-state-item-count">127</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/youngboy/categories/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngboy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/youngboy/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/youngboy/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/youngboy/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/youngboy/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/youngboy/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/youngboy/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
