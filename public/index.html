<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/youngboy/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/youngboy/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/youngboy/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/youngboy/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/youngboy/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/youngboy/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/youngboy/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="youngboy">










<meta name="description" content="Java相关文章和Activiti相关文章">
<meta name="keywords" content="youngboy的个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="youngboy">
<meta property="og:url" content="http://www.youngboy.vip/index.html">
<meta property="og:site_name" content="youngboy">
<meta property="og:description" content="Java相关文章和Activiti相关文章">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="youngboy">
<meta name="twitter:description" content="Java相关文章和Activiti相关文章">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/youngboy/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.youngboy.vip/">





  <title>youngboy</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/youngboy/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">youngboy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Java大杂烩</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/youngboy/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/youngboy/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/youngboy/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/youngboy/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/youngboy/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            日程表
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/3/416/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/3/416/" itemprop="url">设计模式</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/Java相关/" itemprop="url" rel="index">
                    <span itemprop="name">Java相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下面是自己学习设计模式的时候做的总结，有些是自己的原创文章，有些是网上写的比较好的文章，保存下来细细消化吧！</p>
<h2 id="创建型模式："><a href="#创建型模式：" class="headerlink" title="创建型模式："></a>创建型模式：</h2><blockquote>
<h3 id="创建型模式概述："><a href="#创建型模式概述：" class="headerlink" title="创建型模式概述："></a>创建型模式概述：</h3></blockquote>
<ul>
<li>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</li>
<li>创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。 </li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/16/1640641afcb7559b?w=491&amp;h=241&amp;f=png&amp;s=51443" alt="创建型模式"></p>
<blockquote>
<h3 id="创建型模式系列文章推荐："><a href="#创建型模式系列文章推荐：" class="headerlink" title="创建型模式系列文章推荐："></a>创建型模式系列文章推荐：</h3></blockquote>
<ul>
<li><strong>单例模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80455972" target="_blank" rel="noopener">深入理解单例模式——只有一个实例</a></p>
<ul>
<li><strong>工厂模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80472071" target="_blank" rel="noopener">深入理解工厂模式——由对象工厂生成对象</a></p>
<ul>
<li><strong>建造者模式：</strong></li>
</ul>
<p><a href="http://blog.csdn.net/qq_34337272/article/details/80540059" target="_blank" rel="noopener">深入理解建造者模式 ——组装复杂的实例</a></p>
<ul>
<li><strong>原型模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/qq_34337272/article/details/80706444" target="_blank" rel="noopener">深入理解原型模式 ——通过复制生成实例</a></p>
<h2 id="结构型模式："><a href="#结构型模式：" class="headerlink" title="结构型模式："></a>结构型模式：</h2><blockquote>
<h3 id="结构型模式概述："><a href="#结构型模式概述：" class="headerlink" title="结构型模式概述："></a>结构型模式概述：</h3></blockquote>
<ul>
<li><strong>结构型模式(Structural Pattern)：</strong> 描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构<br><img src="https://user-gold-cdn.xitu.io/2018/6/16/164064d6b3c205e3?w=719&amp;h=233&amp;f=png&amp;s=270293" alt="结构型模式(Structural Pattern)"></li>
<li><strong>结构型模式可以分为类结构型模式和对象结构型模式：</strong>  <ul>
<li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li>
<li>对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/16/1640655459d766d2?w=378&amp;h=266&amp;f=png&amp;s=59652" alt="结构型模式"></p>
<blockquote>
<h3 id="结构型模式系列文章推荐："><a href="#结构型模式系列文章推荐：" class="headerlink" title="结构型模式系列文章推荐："></a>结构型模式系列文章推荐：</h3></blockquote>
<ul>
<li><strong>适配器模式：</strong></li>
</ul>
<p><a href="https://segmentfault.com/a/1190000011856448" target="_blank" rel="noopener">深入理解适配器模式——加个“适配器”以便于复用</a></p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-adapter-pattern/index.html" target="_blank" rel="noopener">适配器模式原理及实例介绍-IBM</a></p>
<ul>
<li><strong>桥接模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/yangzl2008/article/details/7670996" target="_blank" rel="noopener">设计模式笔记16：桥接模式(Bridge Pattern)</a></p>
<ul>
<li><strong>组合模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/lmb55/article/details/51039781" target="_blank" rel="noopener">大话设计模式—组合模式</a></p>
<ul>
<li><strong>装饰模式：</strong></li>
</ul>
<p><a href="https://www.cnblogs.com/chenxing818/p/4705919.html" target="_blank" rel="noopener">java模式—装饰者模式</a></p>
<p><a href="https://blog.csdn.net/cauchyweierstrass/article/details/48240147" target="_blank" rel="noopener">Java设计模式-装饰者模式</a></p>
<ul>
<li><strong>外观模式：</strong></li>
</ul>
<p><a href="https://www.cnblogs.com/lthIU/p/5860607.html" target="_blank" rel="noopener">java设计模式之外观模式（门面模式）</a></p>
<ul>
<li><strong>享元模式：</strong></li>
</ul>
<p><a href="http://www.jasongj.com/design_pattern/flyweight/" target="_blank" rel="noopener">享元模式</a></p>
<ul>
<li><strong>代理模式：</strong></li>
</ul>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy-pattern/index.html" target="_blank" rel="noopener">代理模式原理及实例讲解 （IBM出品，很不错）</a></p>
<p><a href="https://blog.csdn.net/briblue/article/details/73928350" target="_blank" rel="noopener">轻松学，Java 中的代理模式及动态代理</a></p>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/74203025" target="_blank" rel="noopener">Java代理模式及其应用</a></p>
<h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><blockquote>
<h3 id="行为型模式概述："><a href="#行为型模式概述：" class="headerlink" title="行为型模式概述："></a>行为型模式概述：</h3></blockquote>
<ul>
<li>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</li>
<li>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</li>
<li>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 </li>
</ul>
<p><strong>行为型模式分为类行为型模式和对象行为型模式两种：</strong></p>
<ul>
<li><strong>类行为型模式：</strong> 类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</li>
<li><strong>对象行为型模式：</strong> 对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/6/28/164467dd92c6172c?w=453&amp;h=269&amp;f=png&amp;s=63270" alt="行为型模式"></p>
<ul>
<li><strong>职责链模式：</strong></li>
</ul>
<p><a href="https://blog.csdn.net/jason0539/article/details/45091639" target="_blank" rel="noopener">Java设计模式之责任链模式、职责链模式</a></p>
<p><a href="https://www.cnblogs.com/lizo/p/7503862.html" target="_blank" rel="noopener">责任链模式实现的三种方式</a></p>
<ul>
<li><strong>命令模式：</strong></li>
</ul>
<ul>
<li><strong>解释器模式：</strong></li>
<li><strong>迭代器模式：</strong></li>
<li><strong>中介者模式：</strong></li>
<li><strong>备忘录模式：</strong></li>
<li><strong>观察者模式：</strong></li>
<li><strong>状态模式：</strong></li>
<li><strong>策略模式：</strong></li>
<li><strong>模板方法模式：</strong></li>
<li><strong>访问者模式：</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/8/10/12/125/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/8/10/12/125/" itemprop="url">（5）栈变队列和栈的压入、弹出序列</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据结构与算法/算法题解析/" itemprop="url" rel="index">
                    <span itemprop="name">算法题解析</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/数据结构与算法/算法题解析/剑指offer/" itemprop="url" rel="index">
                    <span itemprop="name">剑指offer</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一-用两个栈实现队列"><a href="#一-用两个栈实现队列" class="headerlink" title="一 用两个栈实现队列"></a>一 用两个栈实现队列</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="问题分析："><a href="#问题分析：" class="headerlink" title="问题分析："></a>问题分析：</h4><p>先来回顾一下栈和队列的基本特点：<br><strong>栈：</strong>后进先出（LIFO）<br><strong>队列：</strong> 先进先出<br>很明显我们需要根据JDK给我们提供的栈的一些基本方法来实现。先来看一下Stack类的一些基本方法：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-4-4/5985000.jpg" alt="Stack类的一些常见方法"></p>
<p>既然题目给了我们两个栈，我们可以这样考虑当push的时候将元素push进stack1，pop的时候我们先把stack1的元素pop到stack2，然后再对stack2执行pop操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）</p>
<h4 id="考察内容："><a href="#考察内容：" class="headerlink" title="考察内容："></a>考察内容：</h4><p>队列+栈</p>
<h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左程云的《程序员代码面试指南》的答案</span></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//当执行push操作时，将元素添加到stack1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果两个队列都为空则抛出异常,说明用户没有push进任何元素</span></span><br><span class="line">        <span class="keyword">if</span>(stack1.empty()&amp;&amp;stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Queue is empty!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果stack2不为空直接对stack2执行pop操作，</span></span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                <span class="comment">//将stack1的元素按后进先出push进stack2里面</span></span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二-栈的压入、弹出序列"><a href="#二-栈的压入、弹出序列" class="headerlink" title="二 栈的压入、弹出序列"></a>二 栈的压入、弹出序列</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h4><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<h4 id="题目分析："><a href="#题目分析：" class="headerlink" title="题目分析："></a><strong>题目分析：</strong></h4><p>这道题想了半天没有思路，参考了Alias的答案，他的思路写的也很详细应该很容易看懂。<br>作者：Alias<br><a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106</a><br>来源：牛客网</p>
<p>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….<br>依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。 </p>
<h4 id="考察内容：-1"><a href="#考察内容：-1" class="headerlink" title="考察内容："></a><strong>考察内容：</strong></h4><p>栈</p>
<h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a><strong>示例代码：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="comment">//这道题没想出来，参考了Alias同学的答案：https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length == <span class="number">0</span> || popA.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//用于标识弹出序列的位置</span></span><br><span class="line">        <span class="keyword">int</span> popIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; pushA.length;i++)&#123;</span><br><span class="line">            s.push(pushA[i]);</span><br><span class="line">            <span class="comment">//如果栈不为空，且栈顶元素等于弹出序列</span></span><br><span class="line">            <span class="keyword">while</span>(!s.empty() &amp;&amp;s.peek() == popA[popIndex])&#123;</span><br><span class="line">                <span class="comment">//出栈</span></span><br><span class="line">                s.pop();</span><br><span class="line">                <span class="comment">//弹出序列向后一位</span></span><br><span class="line">                popIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/10/102/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/10/102/" itemprop="url">干货：计算机网络知识总结</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/计算机网络与数据通信/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络与数据通信</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1></blockquote>
<h3 id="1-计算机概述"><a href="#1-计算机概述" class="headerlink" title="1. 计算机概述 "></a>1. <a href="#一计算机概述">计算机概述 </a></h3><h3 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2. 物理层 "></a>2. <a href="#二物理层">物理层 </a></h3><h3 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3. 数据链路层 "></a>3. <a href="#三数据链路层">数据链路层 </a></h3><h3 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层 "></a>4. <a href="#四网络层">网络层 </a></h3><h3 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5. 运输层 "></a>5. <a href="#五运输层">运输层 </a></h3><h3 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6. 应用层"></a>6. <a href="#六应用层">应用层</a></h3><h2 id="一计算机概述"><a href="#一计算机概述" class="headerlink" title="一计算机概述"></a>一计算机概述</h2><h3 id="（1），基本术语"><a href="#（1），基本术语" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="结点-（node）："><a href="#结点-（node）：" class="headerlink" title="  结点 （node）："></a><font color="#99CC33">  结点 （node）：<font></font></font></h4><pre><code>网络中的结点可以是计算机，集线器，交换机或路由器等。
</code></pre><h4 id="链路（link-）："><a href="#链路（link-）：" class="headerlink" title="  链路（link  ）："></a><font color="#99CC33">  链路（link  ）：</font></h4><pre><code>从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。
</code></pre><h4 id="主机（host）："><a href="#主机（host）：" class="headerlink" title=" 主机（host）："></a><font color="#99CC33"> 主机（host）：</font></h4><pre><code>连接在因特网上的计算机.
</code></pre><h4 id="ISP（Internet-Service-Provider）："><a href="#ISP（Internet-Service-Provider）：" class="headerlink" title=" ISP（Internet Service Provider）："></a><font color="#99CC33"> ISP（Internet Service Provider）：</font></h4><pre><code>因特网服务提供者（提供商）.
</code></pre><h4 id="IXP（Internet-eXchange-Point）："><a href="#IXP（Internet-eXchange-Point）：" class="headerlink" title=" IXP（Internet eXchange Point）："></a><font color="#99CC33"> IXP（Internet eXchange Point）：</font></h4><pre><code>互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.
</code></pre><h4 id="RFC-Request-For-Comments"><a href="#RFC-Request-For-Comments" class="headerlink" title=" RFC(Request For Comments)"></a><font color="#99CC33"> RFC(Request For Comments)</font></h4><pre><code>意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。
</code></pre><h4 id="广域网WAN（Wide-Area-Network）"><a href="#广域网WAN（Wide-Area-Network）" class="headerlink" title=" 广域网WAN（Wide Area Network）"></a><font color="#99CC33"> 广域网WAN（Wide Area Network）</font></h4><pre><code>任务是通过长距离运送主机发送的数据
</code></pre><h4 id="城域网MAN（Metropolitan-Area-Network）"><a href="#城域网MAN（Metropolitan-Area-Network）" class="headerlink" title=" 城域网MAN（Metropolitan Area Network）"></a><font color="#99CC33"> 城域网MAN（Metropolitan Area Network）</font></h4><pre><code>用来讲多个局域网进行互连
</code></pre><h4 id="局域网LAN（Local-Area-Network）"><a href="#局域网LAN（Local-Area-Network）" class="headerlink" title=" 局域网LAN（Local Area Network）"></a><font color="#99CC33"> 局域网LAN（Local Area Network）</font></h4><pre><code>学校或企业大多拥有多个互连的局域网
</code></pre><h4 id="个人区域网PAN（Personal-Area-Network）"><a href="#个人区域网PAN（Personal-Area-Network）" class="headerlink" title=" 个人区域网PAN（Personal Area Network）"></a><font color="#99CC33"> 个人区域网PAN（Personal Area Network）</font></h4><pre><code>在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  
</code></pre><h4 id="端系统（end-system）："><a href="#端系统（end-system）：" class="headerlink" title="  端系统（end system）："></a><font color="#99CC33">  端系统（end system）：</font></h4><pre><code>处在因特网边缘的部分即是连接在因特网上的所有的主机.
</code></pre><h4 id="分组（packet-）："><a href="#分组（packet-）：" class="headerlink" title=" 分组（packet ）："></a><font color="#99CC33"> 分组（packet ）：</font></h4><pre><code>因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。
</code></pre><h4 id="存储转发（store-and-forward-）"><a href="#存储转发（store-and-forward-）" class="headerlink" title=" 存储转发（store and forward ）:"></a><font color="#99CC33"> 存储转发（store and forward ）:</font></h4><pre><code>路由器收到一个分组，先存储下来，再检查气首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。
</code></pre><h4 id="带宽（bandwidth）："><a href="#带宽（bandwidth）：" class="headerlink" title=" 带宽（bandwidth）："></a><font color="#99CC33"> 带宽（bandwidth）：</font></h4><pre><code>在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。
</code></pre><h4 id="吞吐量（throughput-）："><a href="#吞吐量（throughput-）：" class="headerlink" title=" 吞吐量（throughput ）："></a><font color="#99CC33"> 吞吐量（throughput ）：</font></h4><pre><code>表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。
</code></pre><h3 id="（2），重要知识点总结"><a href="#（2），重要知识点总结" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3> <font color="#999999">1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。<br><br> <font color="#999999">2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。<br><br> <font color="#999999">大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。<br><br> <font color="#999999">3，路由器是实现分组交换的关键构件，其任务是转发受到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后在进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组有称为包。分组是在互联网中传送的数据单元，正式由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。<br><br><font color="#999999">4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由西组成边缘部分，其作用是提供连通性和交换。<br><br> <font color="#999999">5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。<br><br> <font color="#999999">6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。<br><br><font color="#999999">7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN,局域网LAN，个人区域网PAN。<br><br> <font color="#999999">8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。<br><br> <font color="#999999">9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。<br><br> <font color="#999999">10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。<br><br>## 二物理层<br>### <font color="#003333">（1），基本术语<font><br>#### <font color="#99CC33">数据（data）：<font><br>    运送消息的实体。<br>#### <font color="#99CC33">信号（signal）：<font><br>    数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。<br>#### <font color="#99CC33">码元（ code）： <font><br>    在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。<br>#### <font color="#99CC33">单工（simplex ）：<font><br>    只能有一个方向的通信而没有反方向的交互。<br>#### <font color="#99CC33">半双工（half duplex ）：<font><br>    通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。<br>#### <font color="#99CC33">全双工（full duplex）： <font><br>    通信的双方可以同时发送和接收信息。<br>#### <font color="#99CC33">奈氏准则：<font><br>    在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。<br>#### <font color="#99CC33">基带信号（baseband signal）：<font><br>    来自信源的信号。指没有经过调制的数字信号或模拟信号。<br>#### <font color="#99CC33"> 带通（频带）信号（bandpass signal）：<font><br>    把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。<br>#### <font color="#99CC33"> 调制（modulation  ）：<font><br>    对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。<br>#### <font color="#99CC33">信噪比（signal-to-noise ratio ）：<font><br>    指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）<br>#### <font color="#99CC33">信道复用（channel multiplexing ）：<font><br>    指多个用户共享同一个信道。（并不一定是同时）<br>#### <font color="#99CC33">比特率（bit rate ）：<font><br>    单位时间（每秒）内传送的比特数。<br>#### <font color="#99CC33">波特率（baud rate）：<font><br>    单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。<br>#### <font color="#99CC33">复用（multiplexing）：<font><br>    共享信道的方法<br>#### <font color="#99CC33">ADSL（Asymmetric Digital Subscriber Line    ）： <font><br>    非对称数字用户线。<br>#### <font color="#99CC33">光纤同轴混合网（HFC网）:<font><br>    在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网<br><br>### <font color="#003333">（2），重要知识点总结<font><br><br> <font color="#999999">1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</font>

 <font color="#999999">2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</font>

 <font color="#999999">3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。</font>

 <font color="#999999">4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</font>

 <font color="#999999">5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</font>

 <font color="#999999">6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</font>

 <font color="#999999">7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</font>

 <font color="#999999">8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</font>

 <font color="#999999">9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。</font>

<h3 id="（3），最重要的知识点"><a href="#（3），最重要的知识点" class="headerlink" title="（3），最重要的知识点"></a><font color="#003333">（3），最重要的知识点<font></font></font></h3><h4 id="①，物理层的任务"><a href="#①，物理层的任务" class="headerlink" title="①，物理层的任务"></a><font color="#003333"><strong>①，物理层的任务</strong><font></font></font></h4> <font color="#999999">透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。</font>

<h4 id="拓展："><a href="#拓展：" class="headerlink" title="拓展："></a>拓展：</h4> <font color="#999999">物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</font>

<h4 id="②，几种常用的信道复用技术"><a href="#②，几种常用的信道复用技术" class="headerlink" title="②，几种常用的信道复用技术"></a><font color="#003333"><strong>②，几种常用的信道复用技术</strong><font></font></font></h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f7a170ec6611?w=1247&amp;h=425&amp;f=png&amp;s=36746" alt="这里写图片描述"></p>
<h3 id="③，几种常用的宽带接入技术，主要是ADSL和FTTx"><a href="#③，几种常用的宽带接入技术，主要是ADSL和FTTx" class="headerlink" title="③，几种常用的宽带接入技术，主要是ADSL和FTTx"></a><font color="#003333"><strong>③，几种常用的宽带接入技术，主要是ADSL和FTTx</strong><font></font></font></h3> <font color="#999999">用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。</font>

<h2 id="三数据链路层"><a href="#三数据链路层" class="headerlink" title="三数据链路层"></a>三数据链路层</h2><h3 id="（1），基本术语-1"><a href="#（1），基本术语-1" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="链路（link）："><a href="#链路（link）：" class="headerlink" title=" 链路（link）："></a><font color="#99CC33"> 链路（link）：<font></font></font></h4><pre><code>一个结点到相邻结点的一段物理链路
</code></pre><h4 id="数据链路（data-link）："><a href="#数据链路（data-link）：" class="headerlink" title=" 数据链路（data link）："></a><font color="#99CC33"> 数据链路（data link）：<font></font></font></h4><pre><code>把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路
</code></pre><h4 id="循环冗余检验CRC（Cyclic-Redundancy-Check）："><a href="#循环冗余检验CRC（Cyclic-Redundancy-Check）：" class="headerlink" title=" 循环冗余检验CRC（Cyclic Redundancy Check）："></a><font color="#99CC33"> 循环冗余检验CRC（Cyclic Redundancy Check）：<font></font></font></h4><pre><code>为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术
</code></pre><h4 id="帧（frame）："><a href="#帧（frame）：" class="headerlink" title="  帧（frame）："></a><font color="#99CC33">  帧（frame）：<font></font></font></h4><pre><code>一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。
</code></pre><h4 id="MTU（Maximum-Transfer-Uint-）："><a href="#MTU（Maximum-Transfer-Uint-）：" class="headerlink" title=" MTU（Maximum Transfer Uint  ）："></a><font color="#99CC33"> MTU（Maximum Transfer Uint  ）：<font></font></font></h4><pre><code>最大传送单元。帧的数据部分的的长度上限。
</code></pre><h4 id="误码率BER（Bit-Error-Rate-）："><a href="#误码率BER（Bit-Error-Rate-）：" class="headerlink" title=" 误码率BER（Bit Error Rate ）："></a><font color="#99CC33"> 误码率BER（Bit Error Rate ）：<font></font></font></h4><pre><code>在一段时间内，传输错误的比特占所传输比特总数的比率。
</code></pre><h4 id="PPP（Point-to-Point-Protocol-）："><a href="#PPP（Point-to-Point-Protocol-）：" class="headerlink" title=" PPP（Point-to-Point Protocol  ）："></a><font color="#99CC33"> PPP（Point-to-Point Protocol  ）：<font></font></font></h4><pre><code>点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:
</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f8291c6b032c?w=624&amp;h=359&amp;f=jpeg&amp;s=44271" alt="PPP"></p>
<h4 id="MAC地址（Media-Access-Control或者Medium-Access-Control）："><a href="#MAC地址（Media-Access-Control或者Medium-Access-Control）：" class="headerlink" title=" MAC地址（Media Access Control或者Medium Access Control）："></a><font color="#99CC33"> MAC地址（Media Access Control或者Medium Access Control）：<font></font></font></h4><pre><code>意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。
在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。
因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。
地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”
</code></pre><h4 id="网桥（bridge）："><a href="#网桥（bridge）：" class="headerlink" title=" 网桥（bridge）："></a><font color="#99CC33"> 网桥（bridge）：<font></font></font></h4><pre><code>一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。
</code></pre><h4 id="交换机（switch-）："><a href="#交换机（switch-）：" class="headerlink" title=" 交换机（switch ）："></a><font color="#99CC33"> 交换机（switch ）：<font></font></font></h4><pre><code>广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥
</code></pre><h3 id="（2），重要知识点总结-1"><a href="#（2），重要知识点总结-1" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><font color="#999999">1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</font>

<font color="#999999">2，数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</font>

<font color="#999999">3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></font>

<font color="#999999">4，<strong>循环冗余检验CRC</strong>是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码</font>

<font color="#999999">5，<strong>点对点协议PPP</strong>是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</font>

<font color="#999999"> 6，PPPoE是为宽带上网的主机使用的链路层协议</font>

<font color="#999999">7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</font>

<font color="#999999">8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）</font>

<font color="#999999">9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的ROM中</strong>。</font>

<font color="#999999">10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</font>

<font color="#999999">11，以太网采用的协议是具有冲突检测的<strong>载波监听多点接入CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道</font>

<font color="#999999">12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</font>

<font color="#999999">13，使用集线器可以在物理层扩展以太网（扩展后的以太网任然是一个网络）</font><br>### <font color="#003333">（3），最重要的知识点<font><br>#### ① <font color="#999999">数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点<font><br>#### ② <font color="#999999">数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong><font><br>#### ③ <font color="#999999">以太网的MAC层硬件地址<font><br>#### ④ <font color="#999999">适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合<font><br><br>## <font color="#003333" id="4">四网络层<font><br>### <font color="#003333">（1），基本术语<font><br><br>#### <font color="#99CC33">虚电路（Virtual Circuit）：<font><br>    在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。<br>#### <font color="#99CC33">IP（Internet Protocol ）：<font><br>    网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。<br> <img src="https://user-gold-cdn.xitu.io/2018/4/1/1627f92f98436286?w=453&amp;h=331&amp;f=jpeg&amp;s=27535" alt="这里写图片描述"><br>#### <font color="#99CC33">ARP（Address Resolution Protocol）：<font><br>    地址解析协议<br>#### <font color="#99CC33">ICMP（Internet Control Message Protocol ）：<font><br>    网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）<br>#### <font color="#99CC33">子网掩码（subnet mask ）：<font><br>    它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。<br>#### <font color="#99CC33"> CIDR（ Classless Inter-Domain Routing ）：<font><br>    无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）<br>#### <font color="#99CC33">默认路由（default route）：<font><br>    当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。<br>#### <font color="#99CC33">路由选择算法（Virtual Circuit）：<font><br>    路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。<br><br>### <font color="#003333">（2），重要知识点总结<font><br><font color="#999999">1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</font>

<font color="#999999">2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</font>

<font color="#999999">3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址市一中分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址</font>

<font color="#999999">4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。</font>

<font color="#999999">5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组</font>

<font color="#999999">6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。</font>

<font color="#999999">7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种   ICMP差错报告报文和ICMP询问报文。</font>

<font color="#999999">8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址弓箭的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播</font>

<font color="#999999">9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密</font>

<font color="#999999">10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</font>

<h3 id="（3），最重要知识点"><a href="#（3），最重要知识点" class="headerlink" title="（3），最重要知识点"></a><font color="#003333">（3），最重要知识点<font></font></font></h3><h4 id="①-虚拟互联网络的概念"><a href="#①-虚拟互联网络的概念" class="headerlink" title="① 虚拟互联网络的概念"></a>① <font color="#999999">虚拟互联网络的概念</font></h4><h4 id="②-IP地址和物理地址的关系"><a href="#②-IP地址和物理地址的关系" class="headerlink" title="② IP地址和物理地址的关系"></a>② <font color="#999999">IP地址和物理地址的关系</font></h4><h4 id="③-传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR"><a href="#③-传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR" class="headerlink" title="③  传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR"></a>③ <font color="#999999"> 传统的分类的IP地址（包括子网掩码）和误分类域间路由选择CIDR</font></h4><h4 id="④-路由选择协议的工作原理"><a href="#④-路由选择协议的工作原理" class="headerlink" title="④   路由选择协议的工作原理"></a>④ <font color="#999999">  路由选择协议的工作原理</font></h4><h2 id="五运输层"><a href="#五运输层" class="headerlink" title="五运输层"></a><font color="#003333" id="5">五运输层<font></font></font></h2><h3 id="（1），基本术语-2"><a href="#（1），基本术语-2" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="进程（process）："><a href="#进程（process）：" class="headerlink" title="进程（process）："></a><font color="#99CC33">进程（process）：<font></font></font></h4><pre><code>指计算机中正在运行的程序实体
</code></pre><h4 id="应用进程互相通信："><a href="#应用进程互相通信：" class="headerlink" title="应用进程互相通信："></a><font color="#99CC33">应用进程互相通信：<font></font></font></h4><pre><code>一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）
</code></pre><h4 id="传输层的复用与分用："><a href="#传输层的复用与分用：" class="headerlink" title="传输层的复用与分用："></a><font color="#99CC33">传输层的复用与分用：<font></font></font></h4><pre><code>复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 
</code></pre><h4 id="TCP（Transmission-Control-Protocol）："><a href="#TCP（Transmission-Control-Protocol）：" class="headerlink" title="TCP（Transmission Control Protocol）："></a><font color="#99CC33">TCP（Transmission Control Protocol）：<font></font></font></h4><pre><code>传输控制协议
</code></pre><h4 id="UDP（User-Datagram-Protocol）："><a href="#UDP（User-Datagram-Protocol）：" class="headerlink" title="UDP（User Datagram Protocol）："></a><font color="#99CC33">UDP（User Datagram Protocol）：<font></font></font></h4><pre><code>用户数据报协议
</code></pre><h4 id="端口（port）（link）："><a href="#端口（port）（link）：" class="headerlink" title="端口（port）（link）："></a><font color="#99CC33">端口（port）（link）：<font></font></font></h4><pre><code>端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 
</code></pre><h4 id="停止等待协议（link）："><a href="#停止等待协议（link）：" class="headerlink" title="停止等待协议（link）："></a><font color="#99CC33">停止等待协议（link）：<font></font></font></h4><pre><code>指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。
</code></pre><h4 id="流量控制（link）："><a href="#流量控制（link）：" class="headerlink" title="流量控制（link）："></a><font color="#99CC33">流量控制（link）：<font></font></font></h4><pre><code>就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。
</code></pre><h4 id="拥塞控制（link）："><a href="#拥塞控制（link）：" class="headerlink" title="拥塞控制（link）："></a><font color="#99CC33">拥塞控制（link）：<font></font></font></h4><pre><code>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。
</code></pre><h3 id="（2），重要知识点总结-2"><a href="#（2），重要知识点总结-2" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><p><font color="#999999">1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</font></p>
<p>2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</p>
<p>3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。</p>
<p>4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的运输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>
<p>5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</p>
<p>6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。</p>
<p>7，运输层的端口号分为服务器端使用的端口号（0~1023指派给熟知端口，1024~49151是登记端口号）和客户端暂时使用的端口号（49152~65535）</p>
<p>8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</p>
<p>9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流</p>
<p>10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。</p>
<p> 11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</p>
<p>12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</p>
<p>13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
<p>14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。</p>
<p>15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不晕与发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</p>
<p>16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。</p>
<p>19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。</p>
<p>20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</p>
<p>21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接</p>
<h3 id="（3），最重要的知识点-1"><a href="#（3），最重要的知识点-1" class="headerlink" title="（3），最重要的知识点"></a><font color="#003333">（3），最重要的知识点<font></font></font></h3><h4 id="①-端口和套接字的意义"><a href="#①-端口和套接字的意义" class="headerlink" title="① 端口和套接字的意义"></a>① <font color="#999999">端口和套接字的意义<font></font></font></h4><h4 id="②-无连接UDP的特点"><a href="#②-无连接UDP的特点" class="headerlink" title="② 无连接UDP的特点"></a>② <font color="#999999">无连接UDP的特点<font></font></font></h4><h4 id="③-面向连接TCP的特点"><a href="#③-面向连接TCP的特点" class="headerlink" title="③ 面向连接TCP的特点"></a>③ <font color="#999999">面向连接TCP的特点<font></font></font></h4><h4 id="④-在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议"><a href="#④-在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议" class="headerlink" title="④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议"></a>④ <font color="#999999">在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议<font></font></font></h4><h4 id="①-TCP的滑动窗口，流量控制，拥塞控制和连接管理"><a href="#①-TCP的滑动窗口，流量控制，拥塞控制和连接管理" class="headerlink" title="① TCP的滑动窗口，流量控制，拥塞控制和连接管理"></a>① <font color="#999999">TCP的滑动窗口，流量控制，拥塞控制和连接管理<font></font></font></h4><h2 id="六应用层"><a href="#六应用层" class="headerlink" title="六应用层"></a><font color="#003333" id="6">六应用层<font></font></font></h2><h3 id="（1），基本术语-3"><a href="#（1），基本术语-3" class="headerlink" title="（1），基本术语"></a><font color="#003333">（1），基本术语<font></font></font></h3><h4 id="域名系统（DNS）："><a href="#域名系统（DNS）：" class="headerlink" title="  域名系统（DNS）："></a><font color="#99CC33">  域名系统（DNS）：<font></font></font></h4><pre><code>DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。
</code></pre><h4 id="文件传输协议（FTP）："><a href="#文件传输协议（FTP）：" class="headerlink" title=" 文件传输协议（FTP）："></a><font color="#99CC33"> 文件传输协议（FTP）：<font></font></font></h4><pre><code>FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。
基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念：&quot;下载&quot;（Download）和&quot;上传&quot;（Upload）。
&quot;下载&quot;文件就是从远程主机拷贝文件至自己的计算机上；&quot;上传&quot;文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。
</code></pre><h4 id="简单文件传输协议（TFTP）："><a href="#简单文件传输协议（TFTP）：" class="headerlink" title=" 简单文件传输协议（TFTP）："></a><font color="#99CC33"> 简单文件传输协议（TFTP）：<font></font></font></h4><pre><code>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。
</code></pre><h4 id="远程终端协议（TELENET）："><a href="#远程终端协议（TELENET）：" class="headerlink" title=" 远程终端协议（TELENET）："></a><font color="#99CC33"> 远程终端协议（TELENET）：<font></font></font></h4><pre><code>Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。
可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。
</code></pre><h4 id="万维网（WWW）："><a href="#万维网（WWW）：" class="headerlink" title=" 万维网（WWW）："></a><font color="#99CC33"> 万维网（WWW）：<font></font></font></h4><pre><code>WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“&apos;W3&apos;”，英文全称为“World Wide Web”），中文名字为“万维网”，&quot;环球网&quot;等，常简称为Web。分为Web客户端和Web服务器程序。
WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。
万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。
万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。
</code></pre><h4 id="万维网的大致工作工程："><a href="#万维网的大致工作工程：" class="headerlink" title=" 万维网的大致工作工程："></a><font color="#99CC33"> 万维网的大致工作工程：<font></font></font></h4><p><img src="https://user-gold-cdn.xitu.io/2018/4/1/1627ff96a96087af?w=839&amp;h=610&amp;f=jpeg&amp;s=86703" alt="万维网的大致工作工程"></p>
<h4 id="统一资源定位符（URL）："><a href="#统一资源定位符（URL）：" class="headerlink" title=" 统一资源定位符（URL）："></a><font color="#99CC33"> 统一资源定位符（URL）：<font></font></font></h4><pre><code>统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 
</code></pre><h4 id="超文本传输协议（HTTP）："><a href="#超文本传输协议（HTTP）：" class="headerlink" title=" 超文本传输协议（HTTP）："></a><font color="#99CC33"> 超文本传输协议（HTTP）：<font></font></font></h4><pre><code>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。
</code></pre><h4 id="代理服务器（Proxy-Server）："><a href="#代理服务器（Proxy-Server）：" class="headerlink" title=" 代理服务器（Proxy Server）："></a><font color="#99CC33"> 代理服务器（Proxy Server）：<font></font></font></h4><pre><code>代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。
代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。
代理服务器可在客户端或服务器工作，也可以在中间系统工作。 
</code></pre><h4 id="http请求头："><a href="#http请求头：" class="headerlink" title=" http请求头："></a><font color="#99CC33"> http请求头：<font></font></font></h4><pre><code>http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。
- Accept：浏览器可接受的MIME类型。
- Accept-Charset：浏览器可接受的字符集。
- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。
- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。
- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。
- Content-Length：表示请求消息正文的长度。
- Cookie：这是最重要的请求头信息之一
- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。
- Host：初始URL中的主机和端口。
- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。
- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。
- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。
</code></pre><h4 id="简单邮件传输协议-SMTP-："><a href="#简单邮件传输协议-SMTP-：" class="headerlink" title="简单邮件传输协议(SMTP)："></a><font color="#99CC33">简单邮件传输协议(SMTP)：<font></font></font></h4><pre><code>SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。
通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。
</code></pre><h4 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a><font color="#99CC33">搜索引擎：<font></font></font></h4><pre><code>搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。
搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。
</code></pre><h4 id="全文索引："><a href="#全文索引：" class="headerlink" title="全文索引："></a><font color="#99CC33">全文索引：<font></font></font></h4><pre><code> 全文索引技术是目前搜索引擎的关键技术。
试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。
所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。
</code></pre><h4 id="目录索引："><a href="#目录索引：" class="headerlink" title="目录索引："></a><font color="#99CC33">目录索引：<font></font></font></h4><pre><code>目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。
</code></pre><h4 id="垂直搜索引擎："><a href="#垂直搜索引擎：" class="headerlink" title="垂直搜索引擎："></a><font color="#99CC33">垂直搜索引擎：<font></font></font></h4><pre><code>垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。
其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。
</code></pre><h3 id="（2），重要知识点总结-3"><a href="#（2），重要知识点总结-3" class="headerlink" title="（2），重要知识点总结"></a><font color="#003333">（2），重要知识点总结<font></font></font></h3><p><font color="#999999">1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。</font></p>
<p><font color="#999999">2，万维网客户程序与服务器之间进行交互使用的协议时超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式）</font></p>
<p><font color="#999999">3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</font></p>
<p><font color="#999999">4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。</font></p>
<h3 id="（3），最重要知识点总结"><a href="#（3），最重要知识点总结" class="headerlink" title="（3），最重要知识点总结"></a><font color="#003333">（3），最重要知识点总结<font></font></font></h3><h4 id="①-域名系统-从域名解析出IP地址"><a href="#①-域名系统-从域名解析出IP地址" class="headerlink" title="① 域名系统-从域名解析出IP地址"></a>① <font color="#999999">域名系统-从域名解析出IP地址<font></font></font></h4><h4 id="②-访问一个网站大致的过程"><a href="#②-访问一个网站大致的过程" class="headerlink" title="② 访问一个网站大致的过程"></a>② <font color="#999999">访问一个网站大致的过程<font></font></font></h4><h4 id="③-系统调用和应用编程接口概念"><a href="#③-系统调用和应用编程接口概念" class="headerlink" title="③ 系统调用和应用编程接口概念"></a>③ <font color="#999999">系统调用和应用编程接口概念<font></font></font></h4></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font></font>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/111/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/111/" itemprop="url">books</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="核心基础知识"><a href="#核心基础知识" class="headerlink" title="核心基础知识"></a>核心基础知识</h3><ul>
<li><a href="https://book.douban.com/subject/25863515/" target="_blank" rel="noopener">《图解HTTP》</a>（推荐,豆瓣评分 8.1 , 1.6K+人评价）： 讲漫画一样的讲HTTP，很有意思，不会觉得枯燥，大概也涵盖也HTTP常见的知识点。因为篇幅问题，内容可能不太全面。不过，如果不是专门做网络方向研究的小伙伴想研究HTTP相关知识的话，读这本书的话应该来说就差不多了。</li>
<li><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="noopener">《大话数据结构》</a>（推荐，豆瓣评分 7.9 , 1K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有数据结构基础或者说数据结构没学好的小伙伴用来入门数据结构。</li>
<li><a href="https://book.douban.com/subject/1139426/" target="_blank" rel="noopener">《数据结构与算法分析：C语言描述》</a>（推荐，豆瓣评分 8.9，1.6K+人评价）:本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。</li>
<li><a href="https://book.douban.com/subject/26979890/" target="_blank" rel="noopener">《算法图解》</a>（推荐，豆瓣评分 8.4，0.6K+人评价）：入门类型的书籍，读起来比较浅显易懂，适合没有算法基础或者说算法没学好的小伙伴用来入门。示例丰富，图文并茂，以让人容易理解的方式阐释了算法.读起来比较快，内容不枯燥！</li>
<li><a href="https://book.douban.com/subject/10432347/" target="_blank" rel="noopener">《算法 第四版》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：Java语言描述，算法领域经典的参考书，全面介绍了关于算法和数据结构的必备知识，并特别针对排序、搜索、图处理和字符串处理进行了论述。书的内容非常多，可以说是Java程序员的必备书籍之一了。</li>
</ul>
<h3 id="Java相关"><a href="#Java相关" class="headerlink" title="Java相关"></a>Java相关</h3><ul>
<li><a href="https://book.douban.com/subject/3360807/" target="_blank" rel="noopener">《Effective java 》</a>（推荐，豆瓣评分 9.0，1.4K+人评价）：本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。</li>
<li><a href="https://book.douban.com/subject/2000732/" target="_blank" rel="noopener">《Head First Java.第二版》</a>(推荐，豆瓣评分 8.7，1.0K+人评价)：  可以说是我的Java启蒙书籍了，特别适合新手读当然也适合我们用来温故Java知识点。</li>
<li><a href="https://book.douban.com/subject/26555197/" target="_blank" rel="noopener">《Java多线程编程核心技术》</a>： Java多线程入门级书籍还不错，但是说实话，质量不是很高，很快就可以阅读完。</li>
<li><a href="https://book.douban.com/subject/26259017/" target="_blank" rel="noopener">《JAVA网络编程 第4版》</a>：  可以系统的学习一下网络的一些概念以及网络编程在Java中的使用。</li>
<li><a href="https://book.douban.com/subject/25762168/" target="_blank" rel="noopener">《Java核心技术卷1+卷2》</a>（推荐）: 很棒的两本书，建议有点Java基础之后再读，介绍的还是比较深入的，非常推荐。这两本书我一般也会用来巩固知识点，是两本适合放在自己身边的好书。</li>
<li><a href="https://book.douban.com/subject/2130190/" target="_blank" rel="noopener">《Java编程思想(第4版)》</a>（推荐，豆瓣评分 9.1，3.2K+人评价）：这本书要常读，初学者可以快速概览，中等程序员可以深入看看java，老鸟还可以用之回顾java的体系。这本书之所以厉害，因为它在无形中整合了设计模式，这本书之所以难读，也恰恰在于他对设计模式的整合是无形的。</li>
<li><a href="https://book.douban.com/subject/26591326/" target="_blank" rel="noopener">《Java并发编程的艺术》</a>（推荐，豆瓣评分 7.2，0.2K+人评价）： 这本书不是很适合作为Java并发入门书籍，需要具备一定的JVM基础。我感觉有些东西讲的还是挺深入的，推荐阅读。</li>
<li><a href="https://book.douban.com/subject/26663605/" target="_blank" rel="noopener">《实战Java高并发程序设计》</a>（推荐）：豆瓣评分 8.3 ，书的质量没的说，推荐大家好好看一下。</li>
<li><a href="https://book.douban.com/subject/24841235/" target="_blank" rel="noopener">《Java程序员修炼之道》</a>：  很杂，我只看了前面几章，不太推荐阅读。</li>
<li><a href="https://book.douban.com/subject/24722612/" target="_blank" rel="noopener">《深入理解Java虚拟机（第2版）周志明》</a>（推荐，豆瓣评分 8.9，1.0K+人评价）：建议多刷几遍，书中的所有知识点可以通过JAVA运行时区域和JAVA的内存模型与线程两个大模块罗列完全。 </li>
<li><a href="https://book.douban.com/subject/27038538/" target="_blank" rel="noopener">《Netty实战》</a>（推荐，豆瓣评分 7.8，92人评价）：内容很细，如果想学Netty的话，推荐阅读这本书！</li>
<li><a href="https://book.douban.com/subject/26292004/" target="_blank" rel="noopener">《从Paxos到Zookeeper》</a>（推荐，豆瓣评分 7.8，0.3K人评价）：简要介绍几种典型的分布式一致性协议，以及解决分布式一致性问题的思路，其中重点讲解了Paxos和ZAB协议。同时，本书深入介绍了分布式一致性问题的工业解决方案——ZooKeeper，并着重向读者展示这一分布式协调框架的使用方法、内部实现及运维技巧，旨在帮助读者全面了解ZooKeeper，并更好地使用和运维ZooKeeper。</li>
</ul>
<h3 id="JavaWeb相关"><a href="#JavaWeb相关" class="headerlink" title="JavaWeb相关"></a>JavaWeb相关</h3><ul>
<li><a href="https://book.douban.com/subject/25953851/" target="_blank" rel="noopener">《深入分析Java Web技术内幕》</a>：  感觉还行，涉及的东西也蛮多。</li>
<li><a href="https://book.douban.com/subject/26767354/" target="_blank" rel="noopener">《Spring实战（第4版）》</a>（推荐，豆瓣评分 8.3<br>，0.3K+人评价）：不建议当做入门书籍读，入门的话可以找点国人的书或者视频看。这本定位就相当于是关于Spring的新华字典，只有一些基本概念的介绍和示例，涵盖了Spring的各个方面，但都不够深入。就像作者在最后一页写的那样：“学习Spring，这才刚刚开始”。</li>
<li><a href="https://book.douban.com/subject/4189495/" target="_blank" rel="noopener">《Java Web整合开发王者归来》</a>（已过时）：当时刚开始学的时候就是开的这本书，基本上是完完整整的看完了。不过，我不是很推荐大家看。这本书比较老了，里面很多东西都已经算是过时了。不过，这本书的一个很大优点是：基础知识点概括全面。</li>
<li><a href="https://book.douban.com/subject/26612779/" target="_blank" rel="noopener">《Redis实战》</a>：如果你想了解Redis的一些概念性知识的话，这本书真的非常不错。</li>
<li><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener">《Redis设计与实现》</a>（推荐，豆瓣评分 8.5，0.5K+人评价）</li>
<li><a href="https://book.douban.com/subject/10426640/" target="_blank" rel="noopener">《深入剖析Tomcat》</a>（推荐，豆瓣评分 8.4，0.2K+人评价）：本书深入剖析Tomcat 4和Tomcat 5中的每个组件，并揭示其内部工作原理。通过学习本书，你将可以自行开发Tomcat组件，或者扩展已有的组件。 读完这本书，基本可以摆脱背诵面试题的尴尬。</li>
<li><a href="https://book.douban.com/subject/23008813/" target="_blank" rel="noopener">《高性能MySQL》</a>（推荐，豆瓣评分 9.3，0.4K+人评价）：mysql 领域的经典之作，拥有广泛的影响力。不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。</li>
<li><a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">深入理解Nginx（第2版）</a>：作者讲的非常细致，注释都写的都很工整，对于 Nginx 的开发人员非常有帮助。优点是细致，缺点是过于细致，到处都是代码片段，缺少一些抽象。</li>
<li><a href="https://book.douban.com/subject/27591386/" target="_blank" rel="noopener">《RabbitMQ实战指南》</a>：《RabbitMQ实战指南》从消息中间件的概念和RabbitMQ的历史切入，主要阐述RabbitMQ的安装、使用、配置、管理、运维、原理、扩展等方面的细节。如果你想浅尝RabbitMQ的使用，这本书是你最好的选择；如果你想深入RabbitMQ的原理，这本书也是你最好的选择；总之，如果你想玩转RabbitMQ，这本书一定是最值得看的书之一</li>
<li><a href="https://book.douban.com/subject/27025912/" target="_blank" rel="noopener">《Spring Cloud微服务实战》</a>：从时下流行的微服务架构概念出发，详细介绍了Spring Cloud针对微服务架构中几大核心要素的解决方案和基础组件。对于各个组件的介绍，《Spring Cloud微服务实战》主要以示例与源码结合的方式来帮助读者更好地理解这些组件的使用方法以及运行原理。同时，在介绍的过程中，还包含了作者在实践中所遇到的一些问题和解决思路，可供读者在实践中作为参考。</li>
<li><a href="https://book.douban.com/subject/26780404/" target="_blank" rel="noopener">《第一本Docker书》</a>：Docker入门书籍！</li>
</ul>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul>
<li><a href="https://book.douban.com/subject/4889838/" target="_blank" rel="noopener">《鸟哥的Linux私房菜》</a>（推荐，，豆瓣评分 9.1，0.3K+人评价）：本书是最具知名度的Linux入门书《鸟哥的Linux私房菜基础学习篇》的最新版，全面而详细地介绍了Linux操作系统。全书分为5个部分：第一部分着重说明Linux的起源及功能，如何规划和安装Linux主机；第二部分介绍Linux的文件系统、文件、目录与磁盘的管理；第三部分介绍文字模式接口 shell和管理系统的好帮手shell脚本，另外还介绍了文字编辑器vi和vim的使用方法；第四部分介绍了对于系统安全非常重要的Linux账号的管理，以及主机系统与程序的管理，如查看进程、任务分配和作业管理；第五部分介绍了系统管理员(root)的管理事项，如了解系统运行状况、系统服务，针对登录文件进行解析，对系统进行备份以及核心的管理等。</li>
</ul>
<h3 id="架构相关"><a href="#架构相关" class="headerlink" title="架构相关"></a>架构相关</h3><ul>
<li><a href="https://book.douban.com/subject/25723064/" target="_blank" rel="noopener">《大型网站技术架构：核心原理与案例分析+李智慧》</a>（推荐）:这本书我读过，基本不需要你有什么基础啊~读起来特别轻松，但是却可以学到很多东西，非常推荐了。另外我写过这本书的思维导图，关注我的微信公众号：“Java面试通关手册”回复“大型网站技术架构”即可领取思维导图。</li>
<li><a href="https://book.douban.com/subject/26999243/" target="_blank" rel="noopener">《亿级流量网站架构核心技术》</a>（推荐）：一书总结并梳理了亿级流量网站高可用和高并发原则，通过实例详细介绍了如何落地这些原则。本书分为四部分：概述、高可用原则、高并发原则、案例实战。从负载均衡、限流、降级、隔离、超时与重试、回滚机制、压测与预案、缓存、池化、异步化、扩容、队列等多方面详细介绍了亿级流量网站的架构核心技术，让读者看后能快速运用到实践项目中。</li>
<li><a href="https://book.douban.com/subject/27081188/" target="_blank" rel="noopener">《架构解密从分布式到微服务（Leaderus著）》</a>：很一般的书籍，我就是当做课后图书来阅读的。</li>
</ul>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul>
<li><a href="https://book.douban.com/subject/4262627/" target="_blank" rel="noopener">《重构_改善既有代码的设计》</a>（推荐）：豆瓣 9.1 分，重构书籍的开山鼻祖。</li>
</ul>
<h3 id="课外书籍"><a href="#课外书籍" class="headerlink" title="课外书籍"></a>课外书籍</h3><ul>
<li>《追风筝的人》（推荐）</li>
<li>《穆斯林的葬礼》 （推荐）</li>
<li>《三体》 （推荐）</li>
<li>《活着——余华》  （推荐）</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/112/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/112/" itemprop="url">interviewPrepare</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这是【备战春招/秋招系列】的第二篇文章，主要是简单地介绍如何去准备面试。</p>
<p>不论是校招还是社招都避免不了各种面试、笔试，如何去准备这些东西就显得格外重要。不论是笔试还是面试都是有章可循的，我这个“有章可循”说的意思只是说应对技术面试是可以提前准备。 我其实特别不喜欢那种临近考试就提前背啊记啊各种题的行为，非常反对！我觉得这种方法特别极端，而且在稍有一点经验的面试官面前是根本没有用的。建议大家还是一步一个脚印踏踏实实地走。</p>
<h3 id="1-如何获取大厂面试机会？"><a href="#1-如何获取大厂面试机会？" class="headerlink" title="1  如何获取大厂面试机会？"></a>1  如何获取大厂面试机会？</h3><p><strong>在讲如何获取大厂面试机会之前，先来给大家科普/对比一下两个校招非常常见的概念——春招和秋招。</strong></p>
<ol>
<li><strong>招聘人数</strong> ：秋招多于春招 ；</li>
<li><strong>招聘时间</strong> ： 秋招一般7月左右开始，大概一直持续到10月底。<font color="red">但是大厂（如BAT）都会早开始早结束，所以一定要把握好时间。</font>春招最佳时间为3月，次佳时间为4月，进入5月基本就不会再有春招了（金三银四）。  </li>
<li><strong>应聘难度</strong> ：秋招略大于春招；</li>
<li><strong>招聘公司：</strong>  秋招数量多，而春招数量较少，一般为秋招的补充。 </li>
</ol>
<p><strong>综上，一般来说，秋招的含金量明显是高于春招的。</strong></p>
<p><strong>下面我就说一下我自己知道的一些方法，不过应该也涵盖了大部分获取面试机会的方法。</strong></p>
<ol>
<li><strong>关注大厂官网，随时投递简历（走流程的网申）；</strong></li>
<li><strong>线下参加宣讲会，直接投递简历；</strong></li>
<li><strong>找到师兄师姐/认识的人，帮忙内推（能够让你避开网申简历筛选，笔试筛选，还是挺不错的，不过也还是需要你的简历够棒）；</strong></li>
<li><strong>博客发文被看中/Github优秀开源项目作者，大厂内部人员邀请你面试；</strong></li>
<li><strong>求职类网站投递简历（不是太推荐，适合海投）；</strong></li>
</ol>
<p>除了这些方法，我也遇到过这样的经历：有些大公司的一些部门可能暂时没招够人，然后如果你的亲戚或者朋友刚好在这个公司，而你正好又在寻求offer，那么面试机会基本上是有了，而且这种面试的难度好像一般还普遍比其他正规面试低很多。</p>
<h3 id="2-面试前的准备"><a href="#2-面试前的准备" class="headerlink" title="2  面试前的准备"></a>2  面试前的准备</h3><h3 id="2-1-准备自己的自我介绍"><a href="#2-1-准备自己的自我介绍" class="headerlink" title="2.1 准备自己的自我介绍"></a>2.1 准备自己的自我介绍</h3><p>从HR面、技术面到高管面/部门主管面，面试官一般会让你先自我介绍一下，所以好好准备自己的自我介绍真的非常重要。网上一般建议的是准备好两份自我介绍：一份对hr说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节，项目经验，经历那些就一语带过。</p>
<p>我这里简单分享一下我自己的自我介绍的一个简单的模板吧：</p>
<blockquote>
<p>面试官，您好！我叫某某。大学时间我主要利用课外时间学习某某。在校期间参与过一个某某系统的开发，另外，自己学习过程中也写过很多系统比如某某系统。在学习之余，我比较喜欢通过博客整理分享自己所学知识。我现在是某某社区的认证作者，写过某某很不错的文章。另外，我获得过某某奖,我的Github上开源的某个项目已经有多少Star了。</p>
</blockquote>
<h3 id="2-2-关于着装"><a href="#2-2-关于着装" class="headerlink" title="2.2 关于着装"></a>2.2 关于着装</h3><p>穿西装、打领带、小皮鞋？NO！NO！NO！这是互联网公司面试又不是去走红毯，所以你只需要穿的简单大方就好，不需要太正式。</p>
<h3 id="2-3-随身带上自己的成绩单和简历"><a href="#2-3-随身带上自己的成绩单和简历" class="headerlink" title="2.3 随身带上自己的成绩单和简历"></a>2.3 随身带上自己的成绩单和简历</h3><p>有的公司在面试前都会让你交一份成绩单和简历当做面试中的参考。</p>
<h3 id="2-4-如果需要笔试就提前刷一些笔试题"><a href="#2-4-如果需要笔试就提前刷一些笔试题" class="headerlink" title="2.4 如果需要笔试就提前刷一些笔试题"></a>2.4 如果需要笔试就提前刷一些笔试题</h3><p>平时空闲时间多的可以刷一下笔试题目（牛客网上有很多）。但是不要只刷面试题，不动手code，程序员不是为了考试而存在的。</p>
<h3 id="2-5-花时间一些逻辑题"><a href="#2-5-花时间一些逻辑题" class="headerlink" title="2.5 花时间一些逻辑题"></a>2.5 花时间一些逻辑题</h3><p>面试中发现有些公司都有逻辑题测试环节，并且都把逻辑笔试成绩作为很重要的一个参考。</p>
<h3 id="2-6-准备好自己的项目介绍"><a href="#2-6-准备好自己的项目介绍" class="headerlink" title="2.6 准备好自己的项目介绍"></a>2.6 准备好自己的项目介绍</h3><p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p>
<ol>
<li>对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h3 id="2-7-提前准备技术面试"><a href="#2-7-提前准备技术面试" class="headerlink" title="2.7 提前准备技术面试"></a>2.7 提前准备技术面试</h3><p>搞清楚自己面试中可能涉及哪些知识点、那些知识点是重点。面试中哪些问题会被经常问到、自己改如何回答。(强烈不推荐背题，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</p>
<h3 id="2-7-面试之前做好定向复习"><a href="#2-7-面试之前做好定向复习" class="headerlink" title="2.7 面试之前做好定向复习"></a>2.7 面试之前做好定向复习</h3><p>所谓定向复习就是专门针对你要面试的公司来复习。比如你在面试之前可以在网上找找有没有你要面试的公司的面经。</p>
<p>举个栗子：在我面试 ThoughtWorks 的前几天我就在网上找了一些关于 ThoughtWorks 的技术面的一些文章。然后知道了 ThoughtWorks 的技术面会让我们在之前做的作业的基础上增加一个或两个功能，所以我提前一天就把我之前做的程序重新重构了一下。然后在技术面的时候，简单的改了几行代码之后写个测试就完事了。如果没有提前准备，我觉得 20 分钟我很大几率会完不成这项任务。</p>
<h1 id="3-面试之后复盘"><a href="#3-面试之后复盘" class="headerlink" title="3 面试之后复盘"></a>3 面试之后复盘</h1><p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。我个人觉得面试也像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/113/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/113/" itemprop="url">手把手教你用Markdown写一份高质量的简历</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Markdown-简历模板样式一览"><a href="#Markdown-简历模板样式一览" class="headerlink" title="Markdown 简历模板样式一览"></a>Markdown 简历模板样式一览</h2><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f91e4843bd67?w=800&amp;h=1737&amp;f=png&amp;s=97357" alt=""><br><strong>可以看到我把联系方式放在第一位，因为公司一般会与你联系，所以把联系方式放在第一位也是为了方便联系考虑。</strong></p>
<h2 id="为什么要用-Markdown-写简历？"><a href="#为什么要用-Markdown-写简历？" class="headerlink" title="为什么要用 Markdown 写简历？"></a>为什么要用 Markdown 写简历？</h2><p>Markdown 语法简单，易于上手。使用正确的 Markdown 语言写出来的简历不论是在排版还是格式上都比较干净，易于阅读。另外，使用 Markdown 写简历也会给面试官一种你比较专业的感觉。</p>
<p>除了这些，我觉得使用 Markdown 写简历可以很方便将其与PDF、HTML、PNG格式之间转换。后面我会介绍到转换方法，只需要一条命令你就可以实现 Markdown 到 PDF、HTML 与 PNG之间的无缝切换。</p>
<blockquote>
<p>下面的一些内容我在之前的一篇文章中已经提到过，这里再说一遍，最后会分享如何实现Markdown 到 PDF、HTML、PNG格式之间转换。</p>
</blockquote>
<h2 id="为什么说简历很重要？"><a href="#为什么说简历很重要？" class="headerlink" title="为什么说简历很重要？"></a>为什么说简历很重要？</h2><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<h2 id="写简历的两大法则"><a href="#写简历的两大法则" class="headerlink" title="写简历的两大法则"></a>写简历的两大法则</h2><p>目前写简历的方式有两种普遍被认可，一种是 STAR， 一种是 FAB。</p>
<p><strong>STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p><strong>FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<h2 id="项目经历怎么写？"><a href="#项目经历怎么写？" class="headerlink" title="项目经历怎么写？"></a>项目经历怎么写？</h2><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h2 id="专业技能该怎么写？"><a href="#专业技能该怎么写？" class="headerlink" title="专业技能该怎么写？"></a>专业技能该怎么写？</h2><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写：</p>
<ul>
<li>Dubbo：精通</li>
<li>Spring：精通</li>
<li>Docker：掌握</li>
<li>SOA分布式开发 ：掌握</li>
<li>Spring Cloud:了解</li>
</ul>
<h2 id="简历模板分享"><a href="#简历模板分享" class="headerlink" title="简历模板分享"></a>简历模板分享</h2><p><strong>开源程序员简历模板</strong>： <a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a>（包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板）</p>
<p><strong>上述简历模板的改进版本：</strong> <a href="https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md" target="_blank" rel="noopener">https://github.com/Snailclimb/Java-Guide/blob/master/面试必备/简历模板.md</a> </p>
<h2 id="其他的一些小tips"><a href="#其他的一些小tips" class="headerlink" title="其他的一些小tips"></a>其他的一些小tips</h2><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>
<blockquote>
<p>我们刚刚讲了很多关于如何写简历的内容并且分享了一份 Markdown 格式的简历文档。下面我们来看看如何实现 Markdown 到 HTML格式、PNG格式之间转换。</p>
</blockquote>
<h2 id="Markdown-到-HTML格式、PNG格式之间转换"><a href="#Markdown-到-HTML格式、PNG格式之间转换" class="headerlink" title="Markdown 到 HTML格式、PNG格式之间转换"></a>Markdown 到 HTML格式、PNG格式之间转换</h2><p>网上很难找到一个比较方便并且效果好的转换方法，最后我是通过 Visual Studio Code 的 Markdown PDF 插件完美解决了这个问题！</p>
<h3 id="安装-Markdown-PDF-插件"><a href="#安装-Markdown-PDF-插件" class="headerlink" title="安装 Markdown PDF 插件"></a>安装 Markdown PDF 插件</h3><p><strong>① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9a44103e551?w=1366&amp;h=688&amp;f=png&amp;s=104435" alt="① 打开Visual Studio Code ，按快捷键 F1，选择安装扩展选项"></p>
<p><strong>② 搜索 “Markdown PDF” 插件并安装 ，然后重启</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659f9dbef0d06fb?w=1280&amp;h=420&amp;f=png&amp;s=70510" alt="② 搜索 “Markdown PDF” 插件并安装 ，然后重启"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>随便打开一份 Markdown 文件 点击F1，然后输入export即可！</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659fa0292906150?w=1289&amp;h=468&amp;f=png&amp;s=72178" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/124/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/124/" itemprop="url">程序员的简历之道</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="程序员的简历就该这样写"><a href="#程序员的简历就该这样写" class="headerlink" title="程序员的简历就该这样写"></a>程序员的简历就该这样写</h1><h3 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h3><p><font color="red">一份好的简历可以在整个申请面试以及面试过程中起到非常好的作用。</font> 在不夸大自己能力的情况下，写出一份好的简历也是一项很棒的能力。</p>
<h3 id="2-为什么说简历很重要？"><a href="#2-为什么说简历很重要？" class="headerlink" title="2 为什么说简历很重要？"></a>2 为什么说简历很重要？</h3><h4 id="2-1-先从面试前来说"><a href="#2-1-先从面试前来说" class="headerlink" title="2.1 先从面试前来说"></a>2.1 先从面试前来说</h4><p>假如你是网申，你的简历必然会经过HR的筛选，一张简历HR可能也就花费10秒钟看一下，然后HR就会决定你这一关是Fail还是Pass。</p>
<p>假如你是内推，如果你的简历没有什么优势的话，就算是内推你的人再用心，也无能为力。</p>
<p>另外，就算你通过了筛选，后面的面试中，面试官也会根据你的简历来判断你究竟是否值得他花费很多时间去面试。</p>
<p>所以，简历就像是我们的一个门面一样，它在很大程度上决定了你能否进入到下一轮的面试中。</p>
<h4 id="2-2-再从面试中来说"><a href="#2-2-再从面试中来说" class="headerlink" title="2.2 再从面试中来说"></a>2.2 再从面试中来说</h4><p>我发现大家比较喜欢看面经 ，这点无可厚非，但是大部分面经都没告诉你很多问题都是在特定条件下才问的。举个简单的例子：一般情况下你的简历上注明你会的东西才会被问到（Java、数据结构、网络、算法这些基础是每个人必问的），比如写了你会 redis,那面试官就很大概率会问你 redis 的一些问题。比如：redis的常见数据类型及应用场景、redis是单线程为什么还这么快、 redis 和 memcached 的区别、redis 内存淘汰机制等等。</p>
<p>所以，首先，你要明确的一点是：<strong>你不会的东西就不要写在简历上</strong>。另外，<strong>你要考虑你该如何才能让你的亮点在简历中凸显出来</strong>，比如：你在某某项目做了什么事情解决了什么问题（只要有项目就一定有要解决的问题）、你的某一个项目里使用了什么技术后整体性能和并发量提升了很多等等。</p>
<p>面试和工作是两回事，聪明的人会把面试官往自己擅长的领域领，其他人则被面试官牵着鼻子走。虽说面试和工作是两回事，但是你要想要获得自己满意的 offer ，你自身的实力必须要强。</p>
<h3 id="3-下面这几点你必须知道"><a href="#3-下面这几点你必须知道" class="headerlink" title="3 下面这几点你必须知道"></a>3 下面这几点你必须知道</h3><ol>
<li>大部分公司的HR都说我们不看重学历（骗你的！），但是如果你的学校不出众的话，很难在一堆简历中脱颖而出，除非你的简历上有特别的亮点，比如：某某大厂的实习经历、获得了某某大赛的奖等等。</li>
<li><strong>大部分应届生找工作的硬伤是没有工作经验或实习经历，所以如果你是应届生就不要错过秋招和春招。一旦错过，你后面就极大可能会面临社招，这个时候没有工作经验的你可能就会面临各种碰壁，导致找不到一个好的工作</strong></li>
<li><strong>写在简历上的东西一定要慎重，这是面试官大量提问的地方；</strong></li>
<li><strong>将自己的项目经历完美的展示出来非常重要。</strong></li>
</ol>
<h3 id="4-必须了解的两大法则"><a href="#4-必须了解的两大法则" class="headerlink" title="4  必须了解的两大法则"></a>4  必须了解的两大法则</h3><p><strong>①STAR法则（Situation Task Action Result）：</strong></p>
<ul>
<li><strong>Situation：</strong> 事情是在什么情况下发生；</li>
<li><strong>Task:：</strong> 你是如何明确你的任务的；</li>
<li><strong>Action：</strong> 针对这样的情况分析，你采用了什么行动方式；</li>
<li><strong>Result：</strong> 结果怎样，在这样的情况下你学习到了什么。</li>
</ul>
<p>简而言之，STAR法则，就是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板。不管是什么，合理熟练运用此法则，可以轻松的对面试官描述事物的逻辑方式，表现出自己分析阐述问题的清晰性、条理性和逻辑性。</p>
<p>下面这段内容摘自百度百科，我觉得写的非常不错：</p>
<blockquote>
<p>STAR法则，500强面试题回答时的技巧法则，备受面试者成功者和500强HR的推崇。<br>由于这个法则被广泛应用于面试问题的回答，尽管我们还在写简历阶段，但是，写简历时能把面试的问题就想好，会使自己更加主动和自信，做到简历，面试关联性，逻辑性强，不至于在一个月后去面试，却把简历里的东西都忘掉了（更何况有些朋友会稍微夸大简历内容）<br>在我们写简历时，每个人都要写上自己的工作经历，活动经历，想必每一个同学，都会起码花上半天甚至更长的时间去搜寻脑海里所有有关的经历，争取找出最好的东西写在简历上。<br>但是此时，我们要注意了，简历上的任何一个信息点都有可能成为日后面试时的重点提问对象，所以说，不能只管写上让自己感觉最牛的经历就完事了，要想到今后，在面试中，你所写的经历万一被面试官问到，你真的能回答得流利，顺畅，且能通过这段经历，证明自己正是适合这个职位的人吗？</p>
</blockquote>
<p><strong>②FAB 法则（Feature Advantage Benefit）：</strong></p>
<ul>
<li><strong>Feature：</strong> 是什么；</li>
<li><strong>Advantage：</strong> 比别人好在哪些地方；</li>
<li><strong>Benefit：</strong> 如果雇佣你，招聘方会得到什么好处。</li>
</ul>
<p>简单来说，这个法则主要是让你的面试官知道你的优势、招了你之后对公司有什么帮助。</p>
<h3 id="5-项目经历怎么写？"><a href="#5-项目经历怎么写？" class="headerlink" title="5 项目经历怎么写？"></a>5 项目经历怎么写？</h3><p>简历上有一两个项目经历很正常，但是真正能把项目经历很好的展示给面试官的非常少。对于项目经历大家可以考虑从如下几点来写：</p>
<ol>
<li>对项目整体设计的一个感受</li>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的又或者说你在这个项目用了什么技术实现了什么功能比如:用redis做缓存提高访问速度和并发量、使用消息队列削峰和降流等等。</li>
</ol>
<h3 id="6-专业技能该怎么写？"><a href="#6-专业技能该怎么写？" class="headerlink" title="6 专业技能该怎么写？"></a>6 专业技能该怎么写？</h3><p>先问一下你自己会什么，然后看看你意向的公司需要什么。一般HR可能并不太懂技术，所以他在筛选简历的时候可能就盯着你专业技能的关键词来看。对于公司有要求而你不会的技能，你可以花几天时间学习一下，然后在简历上可以写上自己了解这个技能。比如你可以这样写(下面这部分内容摘自我的简历，大家可以根据自己的情况做一些修改和完善)：</p>
<ul>
<li>计算机网络、数据结构、算法、操作系统等课内基础知识：掌握</li>
<li>Java 基础知识：掌握</li>
<li>JVM 虚拟机（Java内存区域、虚拟机垃圾算法、虚拟垃圾收集器、JVM内存管理）：掌握</li>
<li>高并发、高可用、高性能系统开发：掌握</li>
<li>Struts2、Spring、Hibernate、Ajax、Mybatis、JQuery ：掌握</li>
<li>SSH 整合、SSM 整合、 SOA 架构：掌握</li>
<li>Dubbo： 掌握</li>
<li>Zookeeper: 掌握</li>
<li>常见消息队列: 掌握</li>
<li>Linux：掌握</li>
<li>MySQL常见优化手段：掌握 </li>
<li>Spring Boot +Spring Cloud +Docker:了解</li>
<li>Hadoop 生态相关技术中的 HDFS、Storm、MapReduce、Hive、Hbase ：了解</li>
<li>Python 基础、一些常见第三方库比如OpenCV、wxpy、wordcloud、matplotlib：熟悉</li>
</ul>
<h3 id="7-开源程序员Markdown格式简历模板分享"><a href="#7-开源程序员Markdown格式简历模板分享" class="headerlink" title="7 开源程序员Markdown格式简历模板分享"></a>7 开源程序员Markdown格式简历模板分享</h3><p>分享一个Github上开源的程序员简历模板。包括PHP程序员简历模板、iOS程序员简历模板、Android程序员简历模板、Web前端程序员简历模板、Java程序员简历模板、C/C++程序员简历模板、NodeJS程序员简历模板、架构师简历模板以及通用程序员简历模板 。<br>Github地址：<a href="https://github.com/geekcompany/ResumeSample" target="_blank" rel="noopener">https://github.com/geekcompany/ResumeSample</a></p>
<p>我的下面这篇文章讲了如何写一份Markdown格式的简历，另外，文中还提到了一种实现 Markdown 格式到PDF、HTML、JPEG这几种格式的转换方法。</p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484347&amp;idx=1&amp;sn=a986ea7e199871999a5257bd3ed78be1&amp;chksm=fd9855dacaefdccc2c5d5f8f79c4aa1b608ad5b42936bccaefb99a850a2e6e8e2e910e1b3153&amp;token=719595858&amp;lang=zh_CN#rd" target="_blank" rel="noopener">手把手教你用Markdown写一份高质量的简历</a></p>
<h3 id="8-其他的一些小tips"><a href="#8-其他的一些小tips" class="headerlink" title="8 其他的一些小tips"></a>8 其他的一些小tips</h3><ol>
<li>尽量避免主观表述，少一点语义模糊的形容词，尽量要简洁明了，逻辑结构清晰。</li>
<li>注意排版（不需要花花绿绿的），尽量使用Markdown语法。</li>
<li>如果自己有博客或者个人技术栈点的话，写上去会为你加分很多。</li>
<li>如果自己的Github比较活跃的话，写上去也会为你加分很多。</li>
<li>注意简历真实性，一定不要写自己不会的东西，或者带有欺骗性的内容</li>
<li>项目经历建议以时间倒序排序，另外项目经历不在于多，而在于有亮点。</li>
<li>如果内容过多的话，不需要非把内容压缩到一页，保持排版干净整洁就可以了。</li>
<li>简历最后最好能加上：“感谢您花时间阅读我的简历，期待能有机会和您共事。”这句话，显的你会很有礼貌。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/125/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/125/" itemprop="url">简历模板</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联系方式"><a href="#联系方式" class="headerlink" title="联系方式"></a>联系方式</h1><ul>
<li>手机：</li>
<li>Email：</li>
<li>微信：</li>
</ul>
<h1 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h1><ul>
<li>姓名/性别/出生日期 </li>
<li>本科/xxx计算机系xxx专业/英语六级</li>
<li>技术博客：<a href="http://snailclimb.top/" target="_blank" rel="noopener">http://snailclimb.top/</a> </li>
<li>荣誉奖励：获得了什么奖（获奖时间）</li>
<li>Github：<a href="https://github.com/Snailclimb" target="_blank" rel="noopener">https://github.com/Snailclimb </a></li>
<li>Github Resume: <a href="http://resume.github.io/?Snailclimb" target="_blank" rel="noopener">http://resume.github.io/?Snailclimb</a></li>
<li>期望职位：Java 研发程序员/大数据工程师(Java后台开发为首选)</li>
<li>期望城市：xxx城市</li>
</ul>
<h1 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h1><h2 id="xxx项目"><a href="#xxx项目" class="headerlink" title="xxx项目"></a>xxx项目</h2><h3 id="项目描述"><a href="#项目描述" class="headerlink" title="项目描述"></a>项目描述</h3><p>介绍该项目是做什么的、使用到了什么技术以及你对项目整体设计的一个感受</p>
<h3 id="责任描述"><a href="#责任描述" class="headerlink" title="责任描述"></a>责任描述</h3><p>主要可以从下面三点来写：</p>
<ol>
<li>在这个项目中你负责了什么、做了什么、担任了什么角色</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用</li>
<li>另外项目描述中，最好可以体现自己的综合素质，比如你是如何协调项目组成员协同开发的或者在遇到某一个棘手的问题的时候你是如何解决的。</li>
</ol>
<h1 id="开源项目和技术文章"><a href="#开源项目和技术文章" class="headerlink" title="开源项目和技术文章"></a>开源项目和技术文章</h1><h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><ul>
<li><a href="https://github.com/Snailclimb/Java-Guide" target="_blank" rel="noopener">Java-Guide</a> ：一份涵盖大部分Java程序员所需要掌握的核心知识。Star:3.9K; Fork:0.9k。</li>
</ul>
<h2 id="技术文章推荐"><a href="#技术文章推荐" class="headerlink" title="技术文章推荐"></a>技术文章推荐</h2><ul>
<li><a href="https://juejin.im/post/5b7d69e4e51d4538ca5730cb" target="_blank" rel="noopener">可能是把Java内存区域讲的最清楚的一篇文章</a></li>
<li><a href="https://juejin.im/post/5b85ea54e51d4538dd08f601" target="_blank" rel="noopener">搞定JVM垃圾回收就是这么简单</a></li>
<li><a href="https://juejin.im/post/5b3b19856fb9a04fa42f8c71" target="_blank" rel="noopener">前端&amp;后端程序员必备的Linux基础知识</a></li>
<li><a href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a" target="_blank" rel="noopener">可能是把Docker的概念讲的最清楚的一篇文章</a></li>
</ul>
<h1 id="校园经历（可选）"><a href="#校园经历（可选）" class="headerlink" title="校园经历（可选）"></a>校园经历（可选）</h1><h2 id="2016-2017"><a href="#2016-2017" class="headerlink" title="2016-2017"></a>2016-2017</h2><p>担任学校社团-致深社副会长，主要负责团队每周活动的组建以及每周例会的主持。</p>
<h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p> 担任学校传媒组织：“长江大学在线信息传媒”的副站长以及安卓组成员。主要负责每周例会主持、活动策划以及学校校园通APP的研发工作。</p>
<h1 id="技能清单"><a href="#技能清单" class="headerlink" title="技能清单"></a>技能清单</h1><p>以下均为我熟练使用的技能</p>
<ul>
<li>Web开发：PHP/Hack/Node</li>
<li>Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP</li>
<li>前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic</li>
<li>前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap</li>
<li>数据库相关：MySQL/PgSQL/PDO/SQLite</li>
<li>版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer</li>
<li>单元测试：PHPUnit/SimpleTest/Qunit</li>
<li>云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发</li>
</ul>
<h1 id="自我评价（可选）"><a href="#自我评价（可选）" class="headerlink" title="自我评价（可选）"></a>自我评价（可选）</h1><p>自我发挥。切记不要过度自夸！！！</p>
<h3 id="感谢您花时间阅读我的简历，期待能有机会和您共事。"><a href="#感谢您花时间阅读我的简历，期待能有机会和您共事。" class="headerlink" title="感谢您花时间阅读我的简历，期待能有机会和您共事。"></a>感谢您花时间阅读我的简历，期待能有机会和您共事。</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/126/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/126/" itemprop="url">美团-基础篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->
<ul>
<li><a href="#1-systemoutprintln3-|-9输出什么">1.  <code>System.out.println(3 | 9);</code>输出什么？</a></li>
<li><a href="#2-说一下转发forward和重定向redirect的区别">2. 说一下转发(Forward)和重定向(Redirect)的区别</a></li>
<li><a href="#3-在浏览器中输入url地址到显示主页的过程整个过程会使用哪些协议">3.  在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</a></li>
<li><a href="#4-tcp-三次握手和四次挥手">4.  TCP 三次握手和四次挥手</a><ul>
<li><a href="#为什么要三次握手">为什么要三次握手</a></li>
<li><a href="#为什么要传回-syn">为什么要传回 SYN</a></li>
<li><a href="#传了-syn为啥还要传-ack">传了 SYN,为啥还要传 ACK</a></li>
<li><a href="#为什么要四次挥手">为什么要四次挥手</a></li>
</ul>
</li>
<li><a href="#5-ip地址与mac地址的区别">5. IP地址与MAC地址的区别</a></li>
<li><a href="#6-http请求响应报文格式">6. HTTP请求、响应报文格式</a></li>
<li><a href="#7-为什么要使用索引索引这么多优点为什么不对表中的每一个列创建一个索引呢索引是如何提高查询速度的说一下使用索引的注意事项mysql索引主要使用的两种数据结构什么是覆盖索引">7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</a></li>
<li><a href="#8-进程与线程的区别是什么进程间的几种通信方式说一下线程间的几种通信方式知道不">8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</a></li>
<li><a href="#9-为什么要用单例模式手写几种线程安全的单例模式">9. 为什么要用单例模式？手写几种线程安全的单例模式？</a></li>
<li><a href="#10-简单介绍一下bean知道spring的bean的作用域与生命周期吗">10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</a></li>
<li><a href="#11-spring-中的事务传播行为了解吗transactiondefinition-接口中哪五个表示隔离级别的常量">11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</a><ul>
<li><a href="#事务传播行为">事务传播行为</a></li>
<li><a href="#隔离级别">隔离级别</a></li>
</ul>
</li>
<li><a href="#12-springmvc-原理了解吗">12. SpringMVC 原理了解吗？</a></li>
<li><a href="#13-spring-aop-ioc-实现原理">13. Spring AOP IOC 实现原理</a></li>
</ul>
<!-- /MarkdownTOC -->
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-10/3586727.jpg" alt="备战春招/秋招系列】美团面经总结基础篇 （附详解答案）"></p>
<p><strong>系列文章：</strong></p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484573&amp;idx=1&amp;sn=8c5965d4a3710d405d8e8cc10c7b0ce5&amp;chksm=fd9852fccaefdbea8dfe0bc40188b7579f1cddb1e8905dc981669a3f21d2a04cadceafa9023f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列1】程序员的简历就该这样写</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484592&amp;idx=1&amp;sn=6d9731ce7401be49e97c1af6ed384ecc&amp;chksm=fd9852d1caefdbc720a361ae65a8ad9d53cfb4800b15a7c68cbdc630b313215c6c52e0934ec2&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列3】Java程序员必备书单</a></li>
</ul>
<p>这是我总结的美团面经的基础篇，后面还有进阶和终结篇哦！下面只是我从很多份美团面经中总结的在面试中一些常见的问题。不同于个人面经，这份面经具有普适性。每次面试必备的自我介绍、项目介绍这些东西，大家可以自己私下好好思考。我在前面的文章中也提到了应该怎么做自我介绍与项目介绍，详情可以查看这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484578&amp;idx=1&amp;sn=eea72d80a2325257f00aaed21d5b226f&amp;chksm=fd9852c3caefdbd52dd8a537cc723ed1509314401b3a669a253ef5bc0360b6fddef48b9c2e94&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列2】初出茅庐的程序员该如何准备面试？</a>。</p>
<h3 id="1-System-out-println-3-9-输出什么？"><a href="#1-System-out-println-3-9-输出什么？" class="headerlink" title="1.  System.out.println(3 | 9);输出什么？"></a>1.  <code>System.out.println(3 | 9);</code>输出什么？</h3><p>正确答案：11.</p>
<p><strong>考察知识点：&amp;和&amp;&amp;；|和||</strong></p>
<p><strong>&amp;和&amp;&amp;：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边都是true时，结果为true；</p>
<p>不同点: &amp;也是位运算符。&amp; 表示在运算时两边都会计算，然后再判断；&amp;&amp;表示先运算符号左边的东西，然后判断是否为true，是true就继续运算右边的然后判断并输出，是false就停下来直接输出不会再运行后面的东西。</p>
<p><strong>|和||：</strong></p>
<p>共同点：两者都可做逻辑运算符。它们都表示运算符的两边任意一边为true，结果为true，两边都不是true，结果就为false；</p>
<p>不同点：|也是位运算符。| 表示两边都会运算，然后再判断结果；|| 表示先运算符号左边的东西，然后判断是否为true，是true就停下来直接输出不会再运行后面的东西，是false就继续运算右边的然后判断并输出。</p>
<p><strong>回到本题：</strong></p>
<p>3 | 9=0011（二进制） | 1001（二进制）=1011（二进制）=11（十进制）</p>
<h3 id="2-说一下转发-Forward-和重定向-Redirect-的区别"><a href="#2-说一下转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="2. 说一下转发(Forward)和重定向(Redirect)的区别"></a>2. 说一下转发(Forward)和重定向(Redirect)的区别</h3><p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forword）</strong> 通过RequestDispatcher对象的<code>forward（HttpServletRequest request,HttpServletResponse response）</code>方法实现的。<code>RequestDispatcher</code> 可以通过<code>HttpServletRequest</code> 的 <code>getRequestDispatcher()</code>方法获得。例如下面的代码就是跳转到 login_success.jsp 页面。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"login_success.jsp"</span>).forward(request, response);</span><br></pre></td></tr></table></figure>
<p><strong>重定向（Redirect）</strong> 是利用服务器返回的状态吗来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过HttpServletRequestResponse的setStatus(int status)方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><strong>从地址栏显示来说:</strong> forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</li>
<li><strong>从数据共享来说:</strong> forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</li>
<li><strong>从运用地方来说:</strong> forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</li>
<li><strong>从效率来说:</strong> forward:高. redirect:低.</li>
</ol>
<h3 id="3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议"><a href="#3-在浏览器中输入url地址到显示主页的过程-整个过程会使用哪些协议" class="headerlink" title="3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议"></a>3. 在浏览器中输入url地址到显示主页的过程,整个过程会使用哪些协议</h3><p>图解（图片来源：《图解HTTP》）：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="状态码"></p>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
</ul>
<h3 id="4-TCP-三次握手和四次挥手"><a href="#4-TCP-三次握手和四次挥手" class="headerlink" title="4. TCP 三次握手和四次挥手"></a>4. TCP 三次握手和四次挥手</h3><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p>
<p><strong>漫画图解：</strong></p>
<p>图片来源：《图解HTTP》<br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e127396541f1?w=864&amp;h=439&amp;f=png&amp;s=226095" alt="TCP三次握手"></p>
<p><strong>简单示意图：</strong><br><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e14233d95972?w=542&amp;h=427&amp;f=jpeg&amp;s=15088" alt="TCP三次握手"></p>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常。</p>
<p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常</p>
<p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常</p>
<p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p>
<h4 id="为什么要传回-SYN"><a href="#为什么要传回-SYN" class="headerlink" title="为什么要传回 SYN"></a>为什么要传回 SYN</h4><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<blockquote>
<p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h4 id="传了-SYN-为啥还要传-ACK"><a href="#传了-SYN-为啥还要传-ACK" class="headerlink" title="传了 SYN,为啥还要传 ACK"></a>传了 SYN,为啥还要传 ACK</h4><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方（主动关闭方）到接收方（被动关闭方）的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/5/8/1633e1676e2ac0a3?w=500&amp;h=340&amp;f=jpeg&amp;s=13406" alt="TCP四次挥手"></p>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li>
</ul>
<h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h4><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p>
<h3 id="5-IP地址与MAC地址的区别"><a href="#5-IP地址与MAC地址的区别" class="headerlink" title="5. IP地址与MAC地址的区别"></a>5. IP地址与MAC地址的区别</h3><p>参考：<a href="https://blog.csdn.net/guoweimelon/article/details/50858597" target="_blank" rel="noopener">https://blog.csdn.net/guoweimelon/article/details/50858597</a></p>
<p>IP地址是指互联网协议地址（Internet Protocol Address）IP Address的缩写。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p>
<p>MAC 地址又称为物理地址、硬件地址，用来定义网络设备的位置。网卡的物理地址通常是由网卡生产厂家写入网卡的，具有全球唯一性。MAC地址用于在网络中唯一标示一个网卡，一台电脑会有一或多个网卡，每个网卡都需要有一个唯一的MAC地址。</p>
<h3 id="6-HTTP请求-响应报文格式"><a href="#6-HTTP请求-响应报文格式" class="headerlink" title="6. HTTP请求,响应报文格式"></a>6. HTTP请求,响应报文格式</h3><p>HTTP请求报文主要由请求行、请求头部、请求正文3部分组成</p>
<p>HTTP响应报文主要由状态行、响应头部、响应正文3部分组成</p>
<p>详细内容可以参考：<a href="https://blog.csdn.net/a19881029/article/details/14002273" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/14002273</a></p>
<h3 id="7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引"><a href="#7-为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引" class="headerlink" title="7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?"></a>7. 为什么要使用索引？索引这么多优点，为什么不对表中的每一个列创建一个索引呢？索引是如何提高查询速度的？说一下使用索引的注意事项？Mysql索引主要使用的两种数据结构？什么是覆盖索引?</h3><p><strong>为什么要使用索引？</strong></p>
<ol>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
<li>可以大大加快 数据的检索速度（大大减少的检索的数据量）,  这也是创建索引的最主要的原因。 </li>
<li>帮助服务器避免排序和临时表</li>
<li>将随机IO变为顺序IO</li>
<li>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</li>
</ol>
<p><strong>索引这么多优点，为什么不对表中的每一个列创建一个索引呢？</strong></p>
<ol>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 </li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 </li>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 </li>
</ol>
<p><strong>索引是如何提高查询速度的？</strong></p>
<p>将无序的数据变成相对有序的数据（就像查目录一样）</p>
<p><strong>说一下使用索引的注意事项</strong></p>
<ol>
<li>避免 where 子句中对宇段施加函数，这会造成无法命中索引。</li>
<li>在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。</li>
<li>将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用</li>
<li>在使用 limit offset 查询缓慢时，可以借助索引来提高性能</li>
</ol>
<p><strong>Mysql索引主要使用的哪两种数据结构？</strong></p>
<ul>
<li>哈希索引：对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</li>
<li>BTree索引：Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。</li>
</ul>
<p>更多关于索引的内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484486&amp;idx=1&amp;sn=215450f11e042bca8a58eac9f4a97686&amp;chksm=fd985227caefdb3117b8375f150676f5824aa20d1ebfdbcfb93ff06e23e26efbafae6cf6b48e&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【思维导图-索引篇】搞定数据库索引就是这么简单</a></p>
<p><strong>什么是覆盖索引?</strong></p>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称<br>之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次,这样就会比较慢。覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<h3 id="8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"><a href="#8-进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？" class="headerlink" title="8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？"></a>8.  进程与线程的区别是什么？进程间的几种通信方式说一下？线程间的几种通信方式知道不？</h3><p> <strong>进程与线程的区别是什么？</strong></p>
<p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。另外，也正是因为共享资源，所以线程中执行时一般都要进行同步和互斥。总的来说，进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p>
<p><strong>进程间的几种通信方式说一下？</strong></p>
<ol>
<li><strong>管道（pipe）</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有血缘关系的进程间使用。进程的血缘关系通常指父子进程关系。管道分为pipe（无名管道）和fifo（命名管道）两种，有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间通信。</li>
<li><strong>信号量（semophore）</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li>
<li><strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中 并由消息队列标识符标识。消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。</li>
<li><strong>信号（signal）</strong>：信号是一种比较复杂的通信方式，用于通知接收进程某一事件已经发生。</li>
<li><strong>共享内存（shared memory）</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问，共享内存是最快的IPC方式，它是针对其他进程间的通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量配合使用，来实现进程间的同步和通信。</li>
<li><strong>套接字（socket）</strong>：套接口也是一种进程间的通信机制，与其他通信机制不同的是它可以用于不同及其间的进程通信。</li>
</ol>
<p><strong>线程间的几种通信方式知道不？</strong></p>
<p>1、锁机制</p>
<ul>
<li>互斥锁：提供了以排它方式阻止数据结构被并发修改的方法。</li>
<li>读写锁：允许多个线程同时读共享数据，而对写操作互斥。</li>
<li>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。</li>
</ul>
<p>2、信号量机制：包括无名线程信号量与有名线程信号量</p>
<p>3、信号机制：类似于进程间的信号处理。</p>
<p>线程间通信的主要目的是用于线程同步，所以线程没有象进程通信中用于数据交换的通信机制。</p>
<h3 id="9-为什么要用单例模式？手写几种线程安全的单例模式？"><a href="#9-为什么要用单例模式？手写几种线程安全的单例模式？" class="headerlink" title="9. 为什么要用单例模式？手写几种线程安全的单例模式？"></a>9. 为什么要用单例模式？手写几种线程安全的单例模式？</h3><p><strong>简单来说使用单例模式可以带来下面几个好处:</strong></p>
<ul>
<li>对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级对象而言，是非常可观的一笔系统开销；</li>
<li>由于 new 操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻 GC 压力，缩短 GC 停顿时间。</li>
</ul>
<p><strong>懒汉式(双重检查加锁版本)</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile保证，当uniqueInstance变量被初始化成Singleton实例时，多个线程可以正确处理uniqueInstance变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//检查实例，如果不存在，就进入同步代码块</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//只有第一次才彻底执行这里的代码</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">               <span class="comment">//进入同步代码块后，再检查一次，如果仍是null，才创建实例</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>静态内部类方式</strong></p>
<p>静态内部实现的单例是懒加载的且线程安全。</p>
<p>只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance（只有第一次使用这个单例的实例的时候才加载，同时不会有线程安全问题）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"><a href="#10-简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？" class="headerlink" title="10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？"></a>10. 简单介绍一下bean。知道Spring的bean的作用域与生命周期吗？</h3><p>在 Spring 中，那些组成应用程序的主体及由 Spring IOC 容器所管理的对象，被称之为 bean。简单地讲，bean 就是由 IOC 容器初始化、装配及管理的对象，除此之外，bean 就与应用程序中的其他对象没有什么区别了。而 bean 的定义以及 bean 相互间的依赖关系将通过配置元数据来描述。</p>
<p>Spring中的bean默认都是单例的，这些单例Bean在多线程程序下如何保证线程安全呢？ 例如对于Web应用来说，Web容器对于每个用户请求都创建一个单独的Sevlet线程来处理请求，引入Spring框架之后，每个Action都是单例的，那么对于Spring托管的单例Service Bean，如何保证其安全呢？ Spring的单例是基于BeanFactory也就是Spring容器的，单例Bean在此容器内只有一个，Java的单例是基于 JVM，每个 JVM 内只有一个实例。</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45773d5dd2e?w=563&amp;h=299&amp;f=webp&amp;s=27930" alt="pring的bean的作用域"></p>
<p>Spring的bean的生命周期以及更多内容可以查看：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484400&amp;idx=2&amp;sn=7201eb365102fce017f89cb3527fb0bc&amp;chksm=fd985591caefdc872a2fac897288119f94c345e4e12150774f960bf5f816b79e4b9b46be3d7f&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">一文轻松搞懂Spring中bean的作用域与生命周期</a></p>
<h3 id="11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？"><a href="#11-Spring-中的事务传播行为了解吗？TransactionDefinition-接口中哪五个表示隔离级别的常量？" class="headerlink" title="11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？"></a>11. Spring 中的事务传播行为了解吗？TransactionDefinition 接口中哪五个表示隔离级别的常量？</h3><h4 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h4><p>事务传播行为（为了解决业务层方法之间互相调用的事务问题）：<br>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。在TransactionDefinition定义中包括了如下几个表示传播行为的常量：</p>
<p><strong>支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li>
<li>TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p><strong>不支持当前事务的情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p><strong>其他情况：</strong></p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong>  使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong> 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong>   允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong>   最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="12-SpringMVC-原理了解吗？"><a href="#12-SpringMVC-原理了解吗？" class="headerlink" title="12. SpringMVC 原理了解吗？"></a>12. SpringMVC 原理了解吗？</h3><p><img src="https://user-gold-cdn.xitu.io/2018/11/10/166fd45787394192?w=1015&amp;h=466&amp;f=webp&amp;s=35352" alt="SpringMVC 原理"></p>
<p>客户端发送请求-&gt; 前端控制器 DispatcherServlet 接受客户端请求 -&gt; 找到处理器映射 HandlerMapping 解析请求对应的 Handler-&gt; HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑 -&gt; 处理器返回一个模型视图 ModelAndView -&gt; 视图解析器进行解析 -&gt; 返回一个视图对象-&gt;前端控制器 DispatcherServlet 渲染数据（Moder）-&gt;将得到视图对象返回给用户</p>
<p>关于 SpringMVC 原理更多内容可以查看我的这篇文章：<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484496&amp;idx=1&amp;sn=5472ffa687fe4a05f8900d8ee6726de4&amp;chksm=fd985231caefdb27fc75b44ecf76b6f43e4617e0b01b3c040f8b8fab32e51dfa5118eed1d6ad&amp;token=1990180468&amp;lang=zh_CN#rd" target="_blank" rel="noopener">SpringMVC 工作原理详解</a></p>
<h3 id="13-Spring-AOP-IOC-实现原理"><a href="#13-Spring-AOP-IOC-实现原理" class="headerlink" title="13. Spring AOP IOC 实现原理"></a>13. Spring AOP IOC 实现原理</h3><p>过了秋招挺长一段时间了，说实话我自己也忘了如何简要概括 Spring AOP IOC 实现原理，就在网上找了一个较为简洁的答案，下面分享给各位。</p>
<p><strong>IOC:</strong> 控制反转也叫依赖注入。IOC利用java反射机制，AOP利用代理模式。IOC 概念看似很抽象，但是很容易理解。说简单点就是将对象交给容器管理，你只需要在spring配置文件中配置对应的bean以及设置相关的属性，让spring容器来生成类的实例对象以及管理对象。在spring容器启动的时候，spring会把你在配置文件中配置的bean都初始化好，然后在你需要调用的时候，就把它已经初始化好的那些bean分配给你需要调用这些bean的类。</p>
<p><strong>AOP：</strong> 面向切面编程。（Aspect-Oriented Programming） 。AOP可以说是对OOP的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码，属于静态代理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.youngboy.vip/youngboy/2019/01/11/11/127/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="youngboy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/youngboy/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="youngboy">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/youngboy/2019/01/11/11/127/" itemprop="url">美团-终结篇</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-11T15:32:51+08:00">
                2019-01-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/youngboy/categories/面试必备/" itemprop="url" rel="index">
                    <span itemprop="name">面试必备</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- MarkdownTOC -->
<ul>
<li><a href="#一-object类有哪些方法">一. Object类有哪些方法?</a><ul>
<li><a href="#11-object类的常见方法总结">1.1 Object类的常见方法总结</a></li>
<li><a href="#12-hashcode与equals">1.2 hashCode与equals</a><ul>
<li><a href="#121-hashcode（）介绍">1.2.1 hashCode（）介绍</a></li>
<li><a href="#122-为什么要有hashcode">1.2.2 为什么要有hashCode</a></li>
<li><a href="#123-hashcode（）与equals（）的相关规定">1.2.3 hashCode（）与equals（）的相关规定</a></li>
<li><a href="#124-为什么两个对象有相同的hashcode值，它们也不一定是相等的？">1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？</a></li>
</ul>
</li>
<li><a href="#13-与equals">1.3  ==与equals</a></li>
</ul>
</li>
<li><a href="#二-concurrenthashmap-相关问题">二 ConcurrentHashMap 相关问题</a><ul>
<li><a href="#21-concurrenthashmap-和-hashtable-的区别">2.1  ConcurrentHashMap 和 Hashtable 的区别</a></li>
<li><a href="#22-concurrenthashmap线程安全的具体实现方式底层具体实现">2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</a><ul>
<li><a href="#jdk17（上面有示意图）">JDK1.7（上面有示意图）</a></li>
<li><a href="#jdk18-（上面有示意图）">JDK1.8 （上面有示意图）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#三-谈谈-synchronized-和-reentrantlock-的区别">三 谈谈 synchronized 和 ReenTrantLock 的区别</a></li>
<li><a href="#四-线程池了解吗？">四 线程池了解吗？</a><ul>
<li><a href="#41-为什么要用线程池？">4.1 为什么要用线程池？</a></li>
<li><a href="#42-java-提供了哪几种线程池？他们各自的使用场景是什么？">4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？</a><ul>
<li><a href="#java-主要提供了下面4种线程池">Java 主要提供了下面4种线程池</a></li>
<li><a href="#各种线程池的适用场景介绍">各种线程池的适用场景介绍</a></li>
</ul>
</li>
<li><a href="#43-创建的线程池的方式">4.3 创建的线程池的方式</a></li>
</ul>
</li>
<li><a href="#五-nginx">五 Nginx</a><ul>
<li><a href="#51-简单介绍一下nginx">5.1 简单介绍一下Nginx</a><ul>
<li><a href="#反向代理">反向代理</a></li>
<li><a href="#负载均衡">负载均衡</a></li>
<li><a href="#动静分离">动静分离</a></li>
</ul>
</li>
<li><a href="#52-为什么要用-nginx-？">5.2 为什么要用 Nginx ？</a></li>
<li><a href="#53-nginx-的四个主要组成部分了解吗？">5.3  Nginx 的四个主要组成部分了解吗？</a></li>
</ul>
</li>
</ul>
<!-- /MarkdownTOC -->
<blockquote>
<p>下面这个问题，面试中经常出现。我觉得不论是出于应付面试还是说更好地掌握Java这门编程语言，大家都要掌握！</p>
</blockquote>
<h1 id="一-Object类有哪些方法"><a href="#一-Object类有哪些方法" class="headerlink" title="一. Object类有哪些方法?"></a>一. Object类有哪些方法?</h1><h3 id="1-1-Object类的常见方法总结"><a href="#1-1-Object类的常见方法总结" class="headerlink" title="1.1 Object类的常见方法总结"></a>1.1 Object类的常见方法总结</h3><p>Object类是一个特殊的类，是所有类的父类。它主要提供了以下11个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass()<span class="comment">//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="comment">//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span><span class="comment">//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException<span class="comment">//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span><span class="comment">//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span><span class="comment">//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException<span class="comment">//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123; &#125;<span class="comment">//实例被垃圾回收器回收的时候触发的操作</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>问完上面这个问题之后，面试官很可能紧接着就会问你“hashCode与equals”相关的问题。</p>
</blockquote>
<h3 id="1-2-hashCode与equals"><a href="#1-2-hashCode与equals" class="headerlink" title="1.2 hashCode与equals"></a>1.2 hashCode与equals</h3><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<h4 id="1-2-1-hashCode（）介绍"><a href="#1-2-1-hashCode（）介绍" class="headerlink" title="1.2.1 hashCode（）介绍"></a>1.2.1 hashCode（）介绍</h4><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode() 函数。另外需要注意的是： Object 的 hashcode 方法是本地方法，也就是用 c 语言或 c++ 实现的，该方法通常用来将对象的 内存地址 转换为整数之后返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h4 id="1-2-2-为什么要有hashCode"><a href="#1-2-2-为什么要有hashCode" class="headerlink" title="1.2.2 为什么要有hashCode"></a>1.2.2 为什么要有hashCode</h4><p><strong>我们以“HashSet如何检查重复”为例子来说明为什么要有hashCode：</strong></p>
<p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head fist java》第二版）。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p>
<h4 id="1-2-3-hashCode（）与equals（）的相关规定"><a href="#1-2-3-hashCode（）与equals（）的相关规定" class="headerlink" title="1.2.3 hashCode（）与equals（）的相关规定"></a>1.2.3 hashCode（）与equals（）的相关规定</h4><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li><strong>因此，equals方法被覆盖过，则hashCode方法也必须被覆盖</strong></li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h4 id="1-2-4-为什么两个对象有相同的hashcode值，它们也不一定是相等的？"><a href="#1-2-4-为什么两个对象有相同的hashcode值，它们也不一定是相等的？" class="headerlink" title="1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？"></a>1.2.4 为什么两个对象有相同的hashcode值，它们也不一定是相等的？</h4><p>在这里解释一位小伙伴的问题。以下内容摘自《Head Fisrt Java》。</p>
<p>因为hashCode() 所使用的杂凑算法也许刚好会让多个对象传回相同的杂凑值。越糟糕的杂凑算法越容易碰撞，但这也与数据值域分布的特性有关（所谓碰撞也就是指的是不同的对象得到相同的 hashCode）。 </p>
<p>我们刚刚也提到了 HashSet,如果 HashSet 在对比的时候，同样的 hashcode 有多个对象，它会使用 equals() 来判断是否真的相同。也就是说 hashcode 只是用来缩小查找成本。</p>
<blockquote>
<p> ==与equals 的对比也是比较常问的基础问题之一！</p>
</blockquote>
<h3 id="1-3-与equals"><a href="#1-3-与equals" class="headerlink" title="1.3  ==与equals"></a>1.3  ==与equals</h3><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖equals()方法。则通过equals()比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了equals()方法。一般，我们都覆盖equals()方法来两个对象的内容相等；若它们的内容相等，则返回true(即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">"true"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
<blockquote>
<p>在<a href="https://mp.weixin.qq.com/s?__biz=MzU4NDQ4MzU5OA==&amp;mid=2247484625&amp;idx=1&amp;sn=9c4fa1f7d4291a5fbd7daa44bac2b012&amp;chksm=fd9852b0caefdba6edcf9a827aa4a17ddc97bf6ad2e5ee6f7e1aa1b443b54444d05d2b76732b&amp;token=723699735&amp;lang=zh_CN#rd" target="_blank" rel="noopener">【备战春招/秋招系列5】美团面经总结进阶篇 （附详解答案）</a> 这篇文章中，我们已经提到了一下关于 HashMap 在面试中常见的问题：HashMap 的底层实现、简单讲一下自己对于红黑树的理解、红黑树这么优秀，为何不直接使用红黑树得了、HashMap 和 Hashtable 的区别/HashSet 和 HashMap 区别。HashMap 和 ConcurrentHashMap 这俩兄弟在一般只要面试中问到集合相关的问题就一定会被问到，所以各位务必引起重视！</p>
</blockquote>
<h1 id="二-ConcurrentHashMap-相关问题"><a href="#二-ConcurrentHashMap-相关问题" class="headerlink" title="二 ConcurrentHashMap 相关问题"></a>二 ConcurrentHashMap 相关问题</h1><h3 id="2-1-ConcurrentHashMap-和-Hashtable-的区别"><a href="#2-1-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="2.1  ConcurrentHashMap 和 Hashtable 的区别"></a>2.1  ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong>  整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong> </p>
<p>图片来源：<a href="http://www.cnblogs.com/chengxiao/p/6842045.html" target="_blank" rel="noopener">http://www.cnblogs.com/chengxiao/p/6842045.html</a></p>
<p>HashTable:<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/50656681.jpg" alt=""></p>
<p>JDK1.7的ConcurrentHashMap：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/33120488.jpg" alt=""><br>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点<br>Node: 链表节点）：<br><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-8-22/97739220.jpg" alt=""></p>
<h3 id="2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#2-2-ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>2.2 ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h3><h4 id="JDK1-7（上面有示意图）"><a href="#JDK1-7（上面有示意图）" class="headerlink" title="JDK1.7（上面有示意图）"></a>JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry  数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<h4 id="JDK1-8-（上面有示意图）"><a href="#JDK1-8-（上面有示意图）" class="headerlink" title="JDK1.8 （上面有示意图）"></a>JDK1.8 （上面有示意图）</h4><p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。</p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h1 id="三-谈谈-synchronized-和-ReenTrantLock-的区别"><a href="#三-谈谈-synchronized-和-ReenTrantLock-的区别" class="headerlink" title="三 谈谈 synchronized 和 ReenTrantLock 的区别"></a>三 谈谈 synchronized 和 ReenTrantLock 的区别</h1><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>
<p><strong>④ 两者的性能已经相差无几</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。</p>
<h1 id="四-线程池了解吗？"><a href="#四-线程池了解吗？" class="headerlink" title="四 线程池了解吗？"></a>四 线程池了解吗？</h1><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1 为什么要用线程池？"></a>4.1 为什么要用线程池？</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。 </p>
<p>这里借用《Java并发编程的艺术》提到的来说一下使用线程池的好处：</p>
<ul>
<li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="4-2-Java-提供了哪几种线程池？他们各自的使用场景是什么？"><a href="#4-2-Java-提供了哪几种线程池？他们各自的使用场景是什么？" class="headerlink" title="4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？"></a>4.2 Java 提供了哪几种线程池？他们各自的使用场景是什么？</h3><h4 id="Java-主要提供了下面4种线程池"><a href="#Java-主要提供了下面4种线程池" class="headerlink" title="Java 主要提供了下面4种线程池"></a>Java 主要提供了下面4种线程池</h4><ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
<li><strong>ScheduledThreadPoolExecutor：</strong>主要用来在给定的延迟后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor又分为：ScheduledThreadPoolExecutor（包含多个线程）和SingleThreadScheduledExecutor （只包含一个线程）两种。</li>
</ul>
<h4 id="各种线程池的适用场景介绍"><a href="#各种线程池的适用场景介绍" class="headerlink" title="各种线程池的适用场景介绍"></a>各种线程池的适用场景介绍</h4><ul>
<li><strong>FixedThreadPool：</strong> 适用于为了满足资源管理需求，而需要限制当前线程数量的应用场景。它适用于负载比较重的服务器；</li>
<li><strong>SingleThreadExecutor：</strong> 适用于需要保证顺序地执行各个任务并且在任意时间点，不会有多个线程是活动的应用场景。</li>
<li><strong>CachedThreadPool：</strong> 适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器；</li>
<li><strong>ScheduledThreadPoolExecutor：</strong> 适用于需要多个后台执行周期任务，同时为了满足资源管理需求而需要限制后台线程的数量的应用场景，</li>
<li><strong>SingleThreadScheduledExecutor：</strong> 适用于需要单个后台线程执行周期任务，同时保证顺序地执行各个任务的应用场景。</li>
</ul>
<h3 id="4-3-创建的线程池的方式"><a href="#4-3-创建的线程池的方式" class="headerlink" title="4.3 创建的线程池的方式"></a>4.3 创建的线程池的方式</h3><p><strong>（1） 使用 Executors 创建</strong></p>
<p>我们上面刚刚提到了 Java 提供的几种线程池，通过 Executors 工具类我们可以很轻松的创建我们上面说的几种线程池。但是实际上我们一般都不是直接使用Java提供好的线程池，另外在《阿里巴巴Java开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 构造函数 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors 返回线程池对象的弊端如下：</span><br><span class="line"></span><br><span class="line">FixedThreadPool 和 SingleThreadExecutor ： 允许请求的队列长度为 Integer.MAX_VALUE,可能堆积大量的请求，从而导致OOM。</span><br><span class="line">CachedThreadPool 和 ScheduledThreadPool ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致OOM。</span><br></pre></td></tr></table></figure>
<p><strong>（2） ThreadPoolExecutor的构造函数创建</strong></p>
<p>我们可以自己直接调用 ThreadPoolExecutor 的构造函数来自己创建线程池。在创建的同时，给 BlockQueue 指定容量就可以了。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">13</span>, <span class="number">13</span>,</span><br><span class="line">        <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">        <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">13</span>));</span><br></pre></td></tr></table></figure>
<p>这种情况下，一旦提交的线程数超过当前可用线程数时，就会抛出java.util.concurrent.RejectedExecutionException，这是因为当前线程池使用的队列是有边界队列，队列已经满了便无法继续处理新的请求。但是异常（Exception）总比发生错误（Error）要好。</p>
<p><strong>（3） 使用开源类库</strong></p>
<p>Hollis 大佬之前在他的文章中也提到了：“除了自己定义ThreadPoolExecutor外。还有其他方法。这个时候第一时间就应该想到开源类库，如apache和guava等。”他推荐使用guava提供的ThreadFactoryBuilder来创建线程池。下面是参考他的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder()</span><br><span class="line">        .setNameFormat(<span class="string">"demo-pool-%d"</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService pool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">200</span>,</span><br><span class="line">        <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(<span class="number">1024</span>), namedThreadFactory, <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">            pool.execute(<span class="keyword">new</span> SubThread());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述方式创建线程时，不仅可以避免OOM的问题，还可以自定义线程名称，更加方便的出错的时候溯源。</p>
<h1 id="五-Nginx"><a href="#五-Nginx" class="headerlink" title="五 Nginx"></a>五 Nginx</h1><h3 id="5-1-简单介绍一下Nginx"><a href="#5-1-简单介绍一下Nginx" class="headerlink" title="5.1 简单介绍一下Nginx"></a>5.1 简单介绍一下Nginx</h3><p>Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 Nginx  主要提供反向代理、负载均衡、动静分离(静态资源服务)等服务。下面我简单地介绍一下这些名词。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>谈到反向代理，就不得不提一下正向代理。无论是正向代理，还是反向代理，说到底，就是代理模式的衍生版本罢了</p>
<ul>
<li><strong>正向代理：</strong>某些情况下，代理我们用户去访问服务器，需要用户手动的设置代理服务器的ip和端口号。正向代理比较常见的一个例子就是 VPN了。</li>
<li><strong>反向代理：</strong> 是用来代理服务器的，代理我们要访问的目标服务器。代理服务器接受请求，然后将请求转发给内部网络的服务器，并将从服务器上得到的结果返回给客户端，此时代理服务器对外就表现为一个服务器。</li>
</ul>
<p>通过下面两幅图，大家应该更好理解（图源：<a href="http://blog.720ui.com/2016/nginx_action_05_proxy/）：" target="_blank" rel="noopener">http://blog.720ui.com/2016/nginx_action_05_proxy/）：</a></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/60925795.jpg" alt="正向代理"></p>
<p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-15/62563930.jpg" alt="反向代理"></p>
<p>所以，简单的理解，就是正向代理是为客户端做代理，代替客户端去访问服务器，而反向代理是为服务器做代理，代替服务器接受客户端请求。</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>在高并发情况下需要使用，其原理就是将并发请求分摊到多个服务器执行，减轻每台服务器的压力，多台服务器(集群)共同完成工作任务，从而提高了数据的吞吐量。</p>
<p>Nginx支持的weight轮询（默认）、ip_hash、fair、url_hash这四种负载均衡调度算法，感兴趣的可以自行查阅。</p>
<p>负载均衡相比于反向代理更侧重的时将请求分担到多台服务器上去，所以谈论负载均衡只有在提供某服务的服务器大于两台时才有意义。</p>
<h4 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p>
<h3 id="5-2-为什么要用-Nginx-？"><a href="#5-2-为什么要用-Nginx-？" class="headerlink" title="5.2 为什么要用 Nginx ？"></a>5.2 为什么要用 Nginx ？</h3><blockquote>
<p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p>
</blockquote>
<p>如果面试官问你这个问题，就一定想看你知道 Nginx 服务器的一些优点吗。</p>
<p>Nginx 有以下5个优点：</p>
<ol>
<li>高并发、高性能（这是其他web服务器不具有的）</li>
<li>可扩展性好（模块化设计，第三方插件生态圈丰富）</li>
<li>高可靠性（可以在服务器行持续不间断的运行数年）</li>
<li>热部署（这个功能对于 Nginx 来说特别重要，热部署指可以在不停止 Nginx服务的情况下升级 Nginx）</li>
<li>BSD许可证（意味着我们可以将源代码下载下来进行修改然后使用自己的版本）</li>
</ol>
<h3 id="5-3-Nginx-的四个主要组成部分了解吗？"><a href="#5-3-Nginx-的四个主要组成部分了解吗？" class="headerlink" title="5.3  Nginx 的四个主要组成部分了解吗？"></a>5.3  Nginx 的四个主要组成部分了解吗？</h3><blockquote>
<p>这部分内容参考极客时间—<a href="https://time.geekbang.org/course/intro/138?code=AycjiiQk6uQRxnVJzBupFkrGkvZlmYELPRsZbWzaAHE=" target="_blank" rel="noopener">Nginx核心知识100讲的内容</a>。</p>
</blockquote>
<ul>
<li>Nginx 二进制可执行文件：由各模块源码编译出一个文件</li>
<li>Nginx.conf 配置文件：控制Nginx 行为</li>
<li>acess.log 访问日志： 记录每一条HTTP请求信息</li>
<li>error.log 错误日志:定位问题</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/youngboy/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/youngboy/page/7/">7</a><a class="extend next" rel="next" href="/youngboy/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">youngboy</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/youngboy/archives/">
              
                  <span class="site-state-item-count">66</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/youngboy/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">youngboy</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/youngboy/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/youngboy/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/youngboy/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/youngboy/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/youngboy/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/youngboy/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/youngboy/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
